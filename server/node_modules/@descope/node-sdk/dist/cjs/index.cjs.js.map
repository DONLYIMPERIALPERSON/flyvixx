{"version":3,"file":"index.cjs.js","sources":["../../lib/fetch-polyfill.ts","../../lib/helpers.ts","../../lib/constants.ts","../../lib/management/paths.ts","../../lib/management/helpers.ts","../../lib/management/user.ts","../../lib/management/tenant.ts","../../lib/management/jwt.ts","../../lib/management/permission.ts","../../lib/management/role.ts","../../lib/management/group.ts","../../lib/management/sso.ts","../../lib/management/accesskey.ts","../../lib/management/flow.ts","../../lib/management/theme.ts","../../lib/management/audit.ts","../../lib/management/authz.ts","../../lib/management/ssoapplication.ts","../../lib/management/password.ts","../../lib/management/fga.ts","../../lib/management/inboundapplication.ts","../../lib/management/outboundapplication.ts","../../lib/management/descoper.ts","../../lib/management/managementKey.ts","../../lib/index.ts","../../lib/management/index.ts","../../lib/management/project.ts","../../lib/errors.ts"],"sourcesContent":["import { fetch as crossFetch, Headers } from 'cross-fetch';\n\nglobalThis.Headers ??= Headers;\n\nconst highWaterMarkMb = 1024 * 1024 * 30; // 30MB\n\n// we are increasing the response buffer size due to an issue where node-fetch hangs when response is too big\nconst patchedFetch = (...args: Parameters<typeof crossFetch>) => {\n  // we can get Request on the first arg, or RequestInfo on the second arg\n  // we want to make sure we are setting the \"highWaterMark\" so we are doing it on both args\n  args.forEach((arg) => {\n    // Updated to only apply highWaterMark to objects, as it can't be applied to strings (it breaks it)\n    if (arg && typeof arg === 'object') {\n      // eslint-disable-next-line no-param-reassign, @typescript-eslint/no-unused-expressions\n      (arg as any).highWaterMark ??= highWaterMarkMb;\n    }\n  });\n\n  return crossFetch(...args);\n};\n\nexport default patchedFetch as unknown as typeof fetch;\n","import type { SdkFnWrapper } from '@descope/core-js-sdk';\nimport { authorizedTenantsClaimName, refreshTokenCookieName } from './constants';\nimport { AuthenticationInfo } from './types';\n\n/**\n * Generate a cookie string from given parameters\n * @param name name of the cookie\n * @param value value of cookie that must be already encoded\n * @param options any options to put on the cookie like cookieDomain, cookieMaxAge, cookiePath\n * @returns Cookie string with all options on the string\n */\nconst generateCookie = (name: string, value: string, options?: Record<string, string | number>) =>\n  `${name}=${value}; Domain=${options?.cookieDomain || ''}; Max-Age=${\n    options?.cookieMaxAge || ''\n  }; Path=${options?.cookiePath || '/'}; HttpOnly; SameSite=Strict`;\n\n/**\n * Parse the cookie string and return the value of the cookie\n * @param cookie the raw cookie string\n * @param name the name of the cookie to get value for\n * @returns the value of the given cookie\n */\nexport const getCookieValue = (cookie: string | null | undefined, name: string) => {\n  const match = cookie?.match(RegExp(`(?:^|[;,]\\\\s*)${name}=([^;]*)`));\n  return match ? match[1] : null;\n};\n\n/**\n * Add cookie generation to core-js functions.\n * @param fn the function we are wrapping\n * @returns Wrapped function with cookie generation\n */\nexport const withCookie: SdkFnWrapper<{ refreshJwt?: string; cookies?: string[] }> =\n  (fn) =>\n  async (...args) => {\n    const resp = await fn(...args);\n\n    // istanbul ignore next\n    if (!resp.data) {\n      return resp;\n    }\n\n    // eslint-disable-next-line prefer-const\n    let { refreshJwt, ...rest } = resp.data;\n    const cookies: string[] = [];\n\n    if (!refreshJwt) {\n      if (resp.response?.headers.get('set-cookie')) {\n        refreshJwt = getCookieValue(\n          resp.response?.headers.get('set-cookie'),\n          refreshTokenCookieName,\n        );\n        cookies.push(resp.response?.headers.get('set-cookie')!);\n      }\n    } else {\n      cookies.push(generateCookie(refreshTokenCookieName, refreshJwt, rest));\n    }\n\n    return { ...resp, data: { ...resp.data, refreshJwt, cookies } };\n  };\n\n/**\n * Get the claim (used for permissions or roles) for a given tenant or top level if tenant is empty\n * @param authInfo The parsed authentication info from the JWT\n * @param claim name of the claim\n * @param tenant tenant to retrieve the claim for\n * @returns the claim for the given tenant or top level if tenant is empty\n */\nexport function getAuthorizationClaimItems(\n  authInfo: AuthenticationInfo,\n  claim: string,\n  tenant?: string,\n): string[] {\n  const value = tenant\n    ? authInfo.token[authorizedTenantsClaimName]?.[tenant]?.[claim]\n    : authInfo.token[claim];\n  return Array.isArray(value) ? value : [];\n}\n\n/**\n * Check if the user is associated with the given tenant\n * @param authInfo The parsed authentication info from the JWT\n * @param tenant tenant to check if user is associated with\n * @returns true if user is associated with the tenant\n */\nexport function isUserAssociatedWithTenant(authInfo: AuthenticationInfo, tenant: string): boolean {\n  return !!authInfo.token[authorizedTenantsClaimName]?.[tenant];\n}\n","/** Refresh JWT cookie name */\nexport const refreshTokenCookieName = 'DSR';\n/** Session JWT cookie name */\nexport const sessionTokenCookieName = 'DS';\n/** The key of the tenants claims in the claims map */\nexport const authorizedTenantsClaimName = 'tenants';\n/** The key of the permissions claims in the claims map either under tenant or top level */\nexport const permissionsClaimName = 'permissions';\n/** The key of the roles claims in the claims map either under tenant or top level */\nexport const rolesClaimName = 'roles';\n","/** API paths for the Descope service Management APIs */\nexport default {\n  user: {\n    create: '/v1/mgmt/user/create',\n    createTestUser: '/v1/mgmt/user/create/test',\n    createBatch: '/v1/mgmt/user/create/batch',\n    update: '/v1/mgmt/user/update',\n    patch: '/v1/mgmt/user/patch',\n    patchBatch: '/v1/mgmt/user/patch/batch',\n    delete: '/v1/mgmt/user/delete',\n    deleteBatch: '/v1/mgmt/user/delete/batch',\n    deleteAllTestUsers: '/v1/mgmt/user/test/delete/all',\n    load: '/v1/mgmt/user',\n    logout: '/v1/mgmt/user/logout',\n    loadUsers: '/v1/mgmt/users/load',\n    search: '/v2/mgmt/user/search',\n    searchTestUsers: '/v2/mgmt/user/search/test',\n    getProviderToken: '/v1/mgmt/user/provider/token',\n    updateStatus: '/v1/mgmt/user/update/status',\n    updateLoginId: '/v1/mgmt/user/update/loginid',\n    updateEmail: '/v1/mgmt/user/update/email',\n    updatePhone: '/v1/mgmt/user/update/phone',\n    updateDisplayName: '/v1/mgmt/user/update/name',\n    updatePicture: '/v1/mgmt/user/update/picture',\n    updateCustomAttribute: '/v1/mgmt/user/update/customAttribute',\n    setRole: '/v1/mgmt/user/update/role/set',\n    addRole: '/v2/mgmt/user/update/role/add',\n    removeRole: '/v1/mgmt/user/update/role/remove',\n    setSSOApps: '/v1/mgmt/user/update/ssoapp/set',\n    addSSOApps: '/v1/mgmt/user/update/ssoapp/add',\n    removeSSOApps: '/v1/mgmt/user/update/ssoapp/remove',\n    addTenant: '/v1/mgmt/user/update/tenant/add',\n    removeTenant: '/v1/mgmt/user/update/tenant/remove',\n    setPassword: '/v1/mgmt/user/password/set', // Deprecated\n    setTemporaryPassword: '/v1/mgmt/user/password/set/temporary',\n    setActivePassword: '/v1/mgmt/user/password/set/active',\n    expirePassword: '/v1/mgmt/user/password/expire',\n    removeAllPasskeys: '/v1/mgmt/user/passkeys/delete',\n    removeTOTPSeed: '/v1/mgmt/user/totp/delete',\n    generateOTPForTest: '/v1/mgmt/tests/generate/otp',\n    generateMagicLinkForTest: '/v1/mgmt/tests/generate/magiclink',\n    generateEnchantedLinkForTest: '/v1/mgmt/tests/generate/enchantedlink',\n    generateEmbeddedLink: '/v1/mgmt/user/signin/embeddedlink',\n    generateSignUpEmbeddedLink: '/v1/mgmt/user/signup/embeddedlink',\n    history: '/v1/mgmt/user/history',\n  },\n  project: {\n    updateName: '/v1/mgmt/project/update/name',\n    updateTags: '/v1/mgmt/project/update/tags',\n    clone: '/v1/mgmt/project/clone',\n    projectsList: '/v1/mgmt/projects/list',\n    exportSnapshot: '/v1/mgmt/project/snapshot/export',\n    importSnapshot: '/v1/mgmt/project/snapshot/import',\n    validateSnapshot: '/v1/mgmt/project/snapshot/validate',\n  },\n  accessKey: {\n    create: '/v1/mgmt/accesskey/create',\n    load: '/v1/mgmt/accesskey',\n    search: '/v1/mgmt/accesskey/search',\n    update: '/v1/mgmt/accesskey/update',\n    deactivate: '/v1/mgmt/accesskey/deactivate',\n    activate: '/v1/mgmt/accesskey/activate',\n    delete: '/v1/mgmt/accesskey/delete',\n  },\n  tenant: {\n    create: '/v1/mgmt/tenant/create',\n    update: '/v1/mgmt/tenant/update',\n    delete: '/v1/mgmt/tenant/delete',\n    load: '/v1/mgmt/tenant',\n    settings: '/v1/mgmt/tenant/settings',\n    loadAll: '/v1/mgmt/tenant/all',\n    searchAll: '/v1/mgmt/tenant/search',\n    generateSSOConfigurationLink: '/v2/mgmt/tenant/adminlinks/sso/generate',\n  },\n  ssoApplication: {\n    oidcCreate: '/v1/mgmt/sso/idp/app/oidc/create',\n    samlCreate: '/v1/mgmt/sso/idp/app/saml/create',\n    oidcUpdate: '/v1/mgmt/sso/idp/app/oidc/update',\n    samlUpdate: '/v1/mgmt/sso/idp/app/saml/update',\n    delete: '/v1/mgmt/sso/idp/app/delete',\n    load: '/v1/mgmt/sso/idp/app/load',\n    loadAll: '/v1/mgmt/sso/idp/apps/load',\n  },\n  inboundApplication: {\n    create: '/v1/mgmt/thirdparty/app/create',\n    update: '/v1/mgmt/thirdparty/app/update',\n    patch: '/v1/mgmt/thirdparty/app/patch',\n    delete: '/v1/mgmt/thirdparty/app/delete',\n    load: '/v1/mgmt/thirdparty/app/load',\n    loadAll: '/v1/mgmt/thirdparty/apps/load',\n    secret: '/v1/mgmt/thirdparty/app/secret',\n    rotate: '/v1/mgmt/thirdparty/app/rotate',\n  },\n  inboundApplicationConsents: {\n    delete: '/v1/mgmt/thirdparty/consents/delete',\n    search: '/v1/mgmt/thirdparty/consents/search',\n  },\n  outboundApplication: {\n    create: '/v1/mgmt/outbound/app/create',\n    update: '/v1/mgmt/outbound/app/update',\n    delete: '/v1/mgmt/outbound/app/delete',\n    load: '/v1/mgmt/outbound/app',\n    loadAll: '/v1/mgmt/outbound/apps',\n    fetchToken: '/v1/mgmt/outbound/app/user/token/latest',\n    fetchTokenByScopes: '/v1/mgmt/outbound/app/user/token',\n    fetchTenantToken: '/v1/mgmt/outbound/app/tenant/token/latest',\n    fetchTenantTokenByScopes: '/v1/mgmt/outbound/app/tenant/token',\n    deleteUserTokens: '/v1/mgmt/outbound/user/tokens',\n    deleteTokenById: '/v1/mgmt/outbound/token',\n  },\n  sso: {\n    settings: '/v1/mgmt/sso/settings',\n    settingsNew: '/v1/mgmt/sso/settings/new',\n    metadata: '/v1/mgmt/sso/metadata',\n    mapping: '/v1/mgmt/sso/mapping',\n    settingsv2: '/v2/mgmt/sso/settings',\n    settingsAllV2: '/v2/mgmt/sso/settings/all',\n    oidc: {\n      configure: '/v1/mgmt/sso/oidc',\n    },\n    saml: {\n      configure: '/v1/mgmt/sso/saml',\n      metadata: '/v1/mgmt/sso/saml/metadata',\n    },\n  },\n  jwt: {\n    update: '/v1/mgmt/jwt/update',\n    impersonate: '/v1/mgmt/impersonate',\n    stopImpersonation: '/v1/mgmt/stop/impersonation',\n    signIn: '/v1/mgmt/auth/signin',\n    signUp: '/v1/mgmt/auth/signup',\n    signUpOrIn: '/v1/mgmt/auth/signup-in',\n    anonymous: '/v1/mgmt/auth/anonymous',\n    clientAssertion: '/v1/mgmt/token/clientassertion',\n  },\n  password: {\n    settings: '/v1/mgmt/password/settings',\n  },\n  permission: {\n    create: '/v1/mgmt/permission/create',\n    update: '/v1/mgmt/permission/update',\n    delete: '/v1/mgmt/permission/delete',\n    loadAll: '/v1/mgmt/permission/all',\n  },\n  role: {\n    create: '/v1/mgmt/role/create',\n    update: '/v1/mgmt/role/update',\n    delete: '/v1/mgmt/role/delete',\n    loadAll: '/v1/mgmt/role/all',\n    search: '/v1/mgmt/role/search',\n  },\n  flow: {\n    list: '/v1/mgmt/flow/list',\n    delete: '/v1/mgmt/flow/delete',\n    export: '/v1/mgmt/flow/export',\n    import: '/v1/mgmt/flow/import',\n    run: '/v1/mgmt/flow/run',\n  },\n  theme: {\n    export: '/v1/mgmt/theme/export',\n    import: '/v1/mgmt/theme/import',\n  },\n  group: {\n    loadAllGroups: '/v1/mgmt/group/all',\n    loadAllGroupsForMember: '/v1/mgmt/group/member/all',\n    loadAllGroupMembers: '/v1/mgmt/group/members',\n  },\n  audit: {\n    search: '/v1/mgmt/audit/search',\n    createEvent: '/v1/mgmt/audit/event',\n  },\n  authz: {\n    schemaSave: '/v1/mgmt/authz/schema/save',\n    schemaDelete: '/v1/mgmt/authz/schema/delete',\n    schemaLoad: '/v1/mgmt/authz/schema/load',\n    nsSave: '/v1/mgmt/authz/ns/save',\n    nsDelete: '/v1/mgmt/authz/ns/delete',\n    rdSave: '/v1/mgmt/authz/rd/save',\n    rdDelete: '/v1/mgmt/authz/rd/delete',\n    reCreate: '/v1/mgmt/authz/re/create',\n    reDelete: '/v1/mgmt/authz/re/delete',\n    reDeleteResources: '/v1/mgmt/authz/re/deleteresources',\n    reDeleteResourceRelationsForResources: '/v1/mgmt/authz/re/deleteresourcesrelations',\n    hasRelations: '/v1/mgmt/authz/re/has',\n    who: '/v1/mgmt/authz/re/who',\n    resource: '/v1/mgmt/authz/re/resource',\n    targets: '/v1/mgmt/authz/re/targets',\n    targetAll: '/v1/mgmt/authz/re/targetall',\n    targetWithRelation: '/v1/mgmt/authz/re/targetwithrelation',\n    getModified: '/v1/mgmt/authz/getmodified',\n  },\n  fga: {\n    schema: '/v1/mgmt/fga/schema',\n    relations: '/v1/mgmt/fga/relations',\n    deleteRelations: '/v1/mgmt/fga/relations/delete',\n    check: '/v1/mgmt/fga/check',\n    resourcesLoad: '/v1/mgmt/fga/resources/load',\n    resourcesSave: '/v1/mgmt/fga/resources/save',\n  },\n  descoper: {\n    create: '/v1/mgmt/descoper',\n    update: '/v1/mgmt/descoper',\n    get: '/v1/mgmt/descoper',\n    delete: '/v1/mgmt/descoper',\n    list: '/v1/mgmt/descoper/list',\n  },\n  managementKey: {\n    create: '/v1/mgmt/managementkey',\n    update: '/v1/mgmt/managementkey',\n    load: '/v1/mgmt/managementkey',\n    delete: '/v1/mgmt/managementkey/delete',\n    search: '/v1/mgmt/managementkey/search',\n  },\n};\n","/* eslint-disable import/prefer-default-export */\nimport { User } from './types';\n\n/**\n * Transforms user objects by converting roles to roleNames\n */\nexport function transformUsersForBatch(users: User[]): any[] {\n  return users.map(({ roles, ...user }) => ({\n    ...user,\n    roleNames: roles,\n  }));\n}\n","import {\n  HttpClient,\n  SdkResponse,\n  transformResponse,\n  UserHistoryResponse,\n  UserResponse,\n  LoginOptions,\n} from '@descope/core-js-sdk';\nimport {\n  ProviderTokenResponse,\n  AssociatedTenant,\n  GenerateEnchantedLinkForTestResponse,\n  GenerateMagicLinkForTestResponse,\n  GenerateOTPForTestResponse,\n  GenerateEmbeddedLinkResponse,\n  AttributesTypes,\n  UserStatus,\n  User,\n  CreateOrInviteBatchResponse,\n  PatchUserBatchResponse,\n  TemplateOptions,\n  ProviderTokenOptions,\n  UserOptions,\n} from './types';\nimport { DeliveryMethodForTestUser } from '../types';\nimport apiPaths from './paths';\nimport { transformUsersForBatch } from './helpers';\n\ntype SearchSort = {\n  field: string;\n  desc?: boolean;\n};\n\ntype RolesList = {\n  values: string[];\n  and?: boolean;\n};\n\ntype SearchRequest = {\n  page?: number;\n  limit?: number;\n  sort?: SearchSort[];\n  text?: string;\n  emails?: string[];\n  phones?: string[];\n  statuses?: UserStatus[];\n  roles?: string[];\n  tenantIds?: string[];\n  customAttributes?: Record<string, AttributesTypes>;\n  withTestUser?: boolean;\n  testUsersOnly?: boolean;\n  ssoAppIds?: string[];\n  loginIds?: string[];\n  userIds?: string[];\n  fromCreatedTime?: number; // Search users created after this time (epoch in milliseconds)\n  toCreatedTime?: number; // Search users created before this time (epoch in milliseconds)\n  fromModifiedTime?: number; // Search users modified after this time (epoch in milliseconds)\n  toModifiedTime?: number; // Search users modified before this time (epoch in milliseconds)\n  tenantRoleIds?: Record<string, RolesList>; // Search users based on tenants and role IDs\n  tenantRoleNames?: Record<string, RolesList>; // Search users based on tenants and role names\n};\n\ntype SingleUserResponse = {\n  user: UserResponse;\n};\n\ntype MultipleUsersResponse = {\n  users: UserResponse[];\n};\n\nconst withUser = (httpClient: HttpClient) => {\n  /* Create User */\n  function create(loginId: string, options?: UserOptions): Promise<SdkResponse<UserResponse>>;\n  function create(\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>>;\n\n  function create(\n    loginId: string,\n    emailOrOptions?: string | UserOptions,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>> {\n    // We support both the old and new parameters forms of create user\n    // 1. The new form - create(loginId, { email, phone, ... }})\n    // 2. The old form - create(loginId, email, phone, ...)\n    const body =\n      typeof emailOrOptions === 'string'\n        ? {\n            loginId,\n            email: emailOrOptions,\n            phone,\n            displayName,\n            givenName,\n            middleName,\n            familyName,\n            roleNames: roles,\n            userTenants,\n            customAttributes,\n            picture,\n            verifiedEmail,\n            verifiedPhone,\n            additionalLoginIds,\n          }\n        : {\n            loginId,\n            ...emailOrOptions,\n            roleNames: emailOrOptions?.roles,\n            roles: undefined,\n          };\n    return transformResponse<SingleUserResponse, UserResponse>(\n      httpClient.post(apiPaths.user.create, body),\n      (data) => data.user,\n    );\n  }\n  /* Create User End */\n\n  /* Create Test User */\n  function createTestUser(\n    loginId: string,\n    options?: UserOptions,\n  ): Promise<SdkResponse<UserResponse>>;\n  function createTestUser(\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>>;\n\n  function createTestUser(\n    loginId: string,\n    emailOrOptions?: string | UserOptions,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>> {\n    // We support both the old and new parameters forms of create test user\n    // 1. The new form - createTestUser(loginId, { email, phone, ... }})\n    // 2. The old form - createTestUser(loginId, email, phone, ...)\n    const body =\n      typeof emailOrOptions === 'string'\n        ? {\n            loginId,\n            email: emailOrOptions,\n            phone,\n            displayName,\n            givenName,\n            middleName,\n            familyName,\n            roleNames: roles,\n            userTenants,\n            customAttributes,\n            picture,\n            verifiedEmail,\n            verifiedPhone,\n            additionalLoginIds,\n            test: true,\n          }\n        : {\n            loginId,\n            ...emailOrOptions,\n            roleNames: emailOrOptions?.roles,\n            roles: undefined,\n            test: true,\n          };\n    return transformResponse<SingleUserResponse, UserResponse>(\n      httpClient.post(apiPaths.user.createTestUser, body),\n      (data) => data.user,\n    );\n  }\n  /* Create Test User End */\n\n  /* Invite User */\n  function invite(\n    loginId: string,\n    options?: UserOptions & {\n      inviteUrl?: string;\n      sendMail?: boolean; // send invite via mail, default is according to project settings\n      sendSMS?: boolean; // send invite via text message, default is according to project settings\n      templateOptions?: TemplateOptions;\n      templateId?: string;\n    },\n  ): Promise<SdkResponse<UserResponse>>;\n  function invite(\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    inviteUrl?: string,\n    sendMail?: boolean, // send invite via mail, default is according to project settings\n    sendSMS?: boolean, // send invite via text message, default is according to project settings\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n    templateId?: string,\n  ): Promise<SdkResponse<UserResponse>>;\n\n  function invite(\n    loginId: string,\n    emailOrOptions?: string | UserOptions,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    inviteUrl?: string,\n    sendMail?: boolean, // send invite via mail, default is according to project settings\n    sendSMS?: boolean, // send invite via text message, default is according to project settings\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n    templateId?: string,\n  ): Promise<SdkResponse<UserResponse>> {\n    // We support both the old and new parameters forms of invite user\n    // 1. The new form - invite(loginId, { email, phone, ... }})\n    // 2. The old form - invite(loginId, email, phone, ...)\n    const body =\n      typeof emailOrOptions === 'string'\n        ? {\n            loginId,\n            email: emailOrOptions,\n            phone,\n            displayName,\n            givenName,\n            middleName,\n            familyName,\n            roleNames: roles,\n            userTenants,\n            invite: true,\n            customAttributes,\n            picture,\n            verifiedEmail,\n            verifiedPhone,\n            inviteUrl,\n            sendMail,\n            sendSMS,\n            additionalLoginIds,\n            templateId,\n          }\n        : {\n            loginId,\n            ...emailOrOptions,\n            roleNames: emailOrOptions?.roles,\n            roles: undefined,\n            invite: true,\n          };\n    return transformResponse<SingleUserResponse, UserResponse>(\n      httpClient.post(apiPaths.user.create, body),\n      (data) => data.user,\n    );\n  }\n  /* Invite User End */\n\n  /* Update User */\n  function update(loginId: string, options?: UserOptions): Promise<SdkResponse<UserResponse>>;\n  function update(\n    loginId: string,\n    email?: string,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>>;\n\n  function update(\n    loginId: string,\n    emailOrOptions?: string | UserOptions,\n    phone?: string,\n    displayName?: string,\n    roles?: string[],\n    userTenants?: AssociatedTenant[],\n    customAttributes?: Record<string, AttributesTypes>,\n    picture?: string,\n    verifiedEmail?: boolean,\n    verifiedPhone?: boolean,\n    givenName?: string,\n    middleName?: string,\n    familyName?: string,\n    additionalLoginIds?: string[],\n  ): Promise<SdkResponse<UserResponse>> {\n    // We support both the old and new parameters forms of update user\n    // 1. The new form - update(loginId, { email, phone, ... }})\n    // 2. The old form - update(loginId, email, phone, ...)\n    const body =\n      typeof emailOrOptions === 'string'\n        ? {\n            loginId,\n            email: emailOrOptions,\n            phone,\n            displayName,\n            givenName,\n            middleName,\n            familyName,\n            roleNames: roles,\n            userTenants,\n            customAttributes,\n            picture,\n            verifiedEmail,\n            verifiedPhone,\n            additionalLoginIds,\n          }\n        : {\n            loginId,\n            ...emailOrOptions,\n            roleNames: emailOrOptions?.roles,\n            roles: undefined,\n          };\n    return transformResponse<SingleUserResponse, UserResponse>(\n      httpClient.post(apiPaths.user.update, body),\n      (data) => data.user,\n    );\n  }\n  /* Update User End */\n\n  /**\n   * Helper function to build patch request body from options\n   * @param loginId The login ID of the user\n   * @param options The fields to update\n   */\n  function buildPatchRequestBody(loginId: string, options: PatchUserOptions): any {\n    const body = {\n      loginId,\n    } as any;\n\n    if (options.email !== undefined) {\n      body.email = options.email;\n    }\n    if (options.phone !== undefined) {\n      body.phone = options.phone;\n    }\n    if (options.displayName !== undefined) {\n      body.displayName = options.displayName;\n    }\n    if (options.givenName !== undefined) {\n      body.givenName = options.givenName;\n    }\n    if (options.middleName !== undefined) {\n      body.middleName = options.middleName;\n    }\n    if (options.familyName !== undefined) {\n      body.familyName = options.familyName;\n    }\n    if (options.roles !== undefined) {\n      body.roleNames = options.roles;\n    }\n    if (options.userTenants !== undefined) {\n      body.userTenants = options.userTenants;\n    }\n    if (options.customAttributes !== undefined) {\n      body.customAttributes = options.customAttributes;\n    }\n    if (options.picture !== undefined) {\n      body.picture = options.picture;\n    }\n    if (options.verifiedEmail !== undefined) {\n      body.verifiedEmail = options.verifiedEmail;\n    }\n    if (options.verifiedPhone !== undefined) {\n      body.verifiedPhone = options.verifiedPhone;\n    }\n    if (options.ssoAppIds !== undefined) {\n      body.ssoAppIds = options.ssoAppIds;\n    }\n    if (options.scim !== undefined) {\n      body.scim = options.scim;\n    }\n    if (options.status !== undefined) {\n      body.status = options.status;\n    }\n\n    return body;\n  }\n\n  /**\n   * Patches an existing user.\n   * @param loginId The login ID of the user\n   * @param options The fields to update. Only the provided ones will be updated.\n   */\n  function patch(loginId: string, options: PatchUserOptions): Promise<SdkResponse<UserResponse>> {\n    const body = buildPatchRequestBody(loginId, options);\n\n    return transformResponse<SingleUserResponse, UserResponse>(\n      httpClient.patch(apiPaths.user.patch, body),\n      (data) => data.user,\n    );\n  }\n\n  /**\n   * Patches multiple users in batch.\n   * @param users Array of patch requests, each containing loginId and the fields to update\n   */\n  function patchBatch(\n    users: Array<{ loginId: string } & PatchUserOptions>,\n  ): Promise<SdkResponse<PatchUserBatchResponse>> {\n    const body = {\n      users: users.map((user) => buildPatchRequestBody(user.loginId, user)),\n    };\n\n    return transformResponse<PatchUserBatchResponse, PatchUserBatchResponse>(\n      httpClient.patch(apiPaths.user.patchBatch, body),\n      (data) => data,\n    );\n  }\n\n  return {\n    create,\n    /**\n     * Create a new test user.\n     * The loginID is required and will determine what the user will use to sign in.\n     * Make sure the login id is unique for test. All other fields are optional.\n     *\n     * You can later generate OTP, Magic link and enchanted link to use in the test without the need\n     * of 3rd party messaging services.\n     * Those users are not counted as part of the monthly active users\n     * @returns The UserResponse if found, throws otherwise.\n     */\n    createTestUser,\n    invite,\n    inviteBatch: (\n      users: User[],\n      inviteUrl?: string,\n      sendMail?: boolean, // send invite via mail, default is according to project settings\n      sendSMS?: boolean, // send invite via text message, default is according to project settings\n      templateOptions?: TemplateOptions,\n      templateId?: string,\n    ): Promise<SdkResponse<CreateOrInviteBatchResponse>> =>\n      transformResponse<CreateOrInviteBatchResponse, CreateOrInviteBatchResponse>(\n        httpClient.post(apiPaths.user.createBatch, {\n          users: transformUsersForBatch(users),\n          invite: true,\n          inviteUrl,\n          sendMail,\n          sendSMS,\n          templateOptions,\n          templateId,\n        }),\n        (data) => data,\n      ),\n    createBatch: (users: User[]): Promise<SdkResponse<CreateOrInviteBatchResponse>> =>\n      transformResponse<CreateOrInviteBatchResponse, CreateOrInviteBatchResponse>(\n        httpClient.post(apiPaths.user.createBatch, {\n          users: transformUsersForBatch(users),\n        }),\n        (data) => data,\n      ),\n    deleteBatch: (userIds: string[]): Promise<SdkResponse<never>> =>\n      transformResponse(httpClient.post(apiPaths.user.deleteBatch, { userIds })),\n    update,\n    patch,\n    patchBatch,\n    /**\n     * Delete an existing user.\n     * @param loginId The login ID of the user\n     */\n    delete: (loginId: string): Promise<SdkResponse<never>> =>\n      transformResponse(httpClient.post(apiPaths.user.delete, { loginId })),\n    /**\n     * Delete an existing user by User ID.\n     * @param userId The user ID can be found in the Subject (`sub`) claim\n     * in the user's JWT.\n     */\n    deleteByUserId: (userId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse(httpClient.post(apiPaths.user.delete, { userId })),\n    /**\n     * Delete all test users in the project.\n     */\n    deleteAllTestUsers: (): Promise<SdkResponse<never>> =>\n      transformResponse(httpClient.delete(apiPaths.user.deleteAllTestUsers)),\n    load: (loginId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.get(apiPaths.user.load, {\n          queryParams: { loginId },\n        }),\n        (data) => data.user,\n      ),\n    /**\n     * Load an existing user by user ID. The ID can be found\n     * on the user's JWT.\n     * @param userId load a user by this user ID field\n     * @returns The UserResponse if found, throws otherwise.\n     */\n    loadByUserId: (userId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.get(apiPaths.user.load, {\n          queryParams: { userId },\n        }),\n        (data) => data.user,\n      ),\n    /**\n     * Logout a user from all devices by the login ID\n     * @param loginId logout user by login ID\n     * @returns The UserResponse if found, throws otherwise.\n     */\n    logoutUser: (loginId: string): Promise<SdkResponse<never>> =>\n      transformResponse(httpClient.post(apiPaths.user.logout, { loginId })),\n    /**\n     * Logout a user from all devices by user ID. The ID can be found\n     * on the user's JWT.\n     * @param userId Logout a user from all devices by this user ID field\n     * @returns The UserResponse if found, throws otherwise.\n     */\n    logoutUserByUserId: (userId: string): Promise<SdkResponse<never>> =>\n      transformResponse(httpClient.post(apiPaths.user.logout, { userId })),\n    /**\n     * loadUsers by their user IDs.\n     * @param userIds list of user IDs to load\n     * @param includeInvalidUsers optionally include disabled/expired users in the response\n     * @returns An array of UserResponse found by the query\n     */\n    loadUsers: (\n      userIds: string[],\n      includeInvalidUsers?: boolean,\n    ): Promise<SdkResponse<UserResponse[]>> =>\n      transformResponse<MultipleUsersResponse, UserResponse[]>(\n        httpClient.post(apiPaths.user.loadUsers, {\n          userIds,\n          includeInvalidUsers,\n        }),\n        (data) => data.users,\n      ),\n    /**\n     * Search all users. Results can be filtered according to tenants and/or\n     * roles, and also paginated used the limit and page parameters.\n     * @deprecated Use search instead\n     * @param tenantIds optional list of tenant IDs to filter by\n     * @param roles optional list of roles to filter by\n     * @param limit optionally limit the response, leave out for default limit\n     * @param page optionally paginate over the response\n     * @param testUsersOnly optionally filter only test users\n     * @param withTestUser optionally include test users in search\n     * @returns An array of UserResponse found by the query\n     */\n    searchAll: (\n      tenantIds?: string[],\n      roles?: string[],\n      limit?: number,\n      page?: number,\n      testUsersOnly?: boolean,\n      withTestUser?: boolean,\n      customAttributes?: Record<string, AttributesTypes>,\n      statuses?: UserStatus[],\n      emails?: string[],\n      phones?: string[],\n    ): Promise<SdkResponse<UserResponse[]>> =>\n      transformResponse<MultipleUsersResponse, UserResponse[]>(\n        httpClient.post(apiPaths.user.search, {\n          tenantIds,\n          roleNames: roles,\n          limit,\n          page,\n          testUsersOnly,\n          withTestUser,\n          customAttributes,\n          statuses,\n          emails,\n          phones,\n        }),\n        (data) => data.users,\n      ),\n    searchTestUsers: (searchReq: SearchRequest): Promise<SdkResponse<UserResponse[]>> =>\n      transformResponse<MultipleUsersResponse, UserResponse[]>(\n        httpClient.post(apiPaths.user.searchTestUsers, {\n          ...searchReq,\n          withTestUser: true,\n          testUsersOnly: true,\n          roleNames: searchReq.roles,\n          roles: undefined,\n        }),\n        (data) => data.users,\n      ),\n    search: (searchReq: SearchRequest): Promise<SdkResponse<UserResponse[]>> =>\n      transformResponse<MultipleUsersResponse, UserResponse[]>(\n        httpClient.post(apiPaths.user.search, {\n          ...searchReq,\n          roleNames: searchReq.roles,\n          roles: undefined,\n        }),\n        (data) => data.users,\n      ),\n    /**\n     * Get the provider token for the given login ID.\n     * Only users that logged-in using social providers will have token.\n     * Note: The 'Manage tokens from provider' setting must be enabled.\n     * @param loginId the login ID of the user\n     * @param provider the provider name (google, facebook, etc.).\n     * @param providerTokenOptions optional, includes options for getting the provider token:\n     *    withRefreshToken - include the refresh token in the response\n     *    forceRefresh - force to refresh the token\n     * @returns The ProviderTokenResponse of the given user and provider\n     */\n    getProviderToken: (\n      loginId: string,\n      provider: string,\n      providerTokenOptions?: ProviderTokenOptions,\n    ): Promise<SdkResponse<ProviderTokenResponse>> =>\n      transformResponse<ProviderTokenResponse>(\n        httpClient.get(apiPaths.user.getProviderToken, {\n          queryParams: {\n            loginId,\n            provider,\n            withRefreshToken: providerTokenOptions?.withRefreshToken ? 'true' : 'false',\n            forceRefresh: providerTokenOptions?.forceRefresh ? 'true' : 'false',\n          },\n        }),\n        (data) => data,\n      ),\n    activate: (loginId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.updateStatus, { loginId, status: 'enabled' }),\n        (data) => data.user,\n      ),\n    deactivate: (loginId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.updateStatus, { loginId, status: 'disabled' }),\n        (data) => data.user,\n      ),\n    updateLoginId: (loginId: string, newLoginId?: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.updateLoginId, { loginId, newLoginId }),\n        (data) => data.user,\n      ),\n    updateEmail: (\n      loginId: string,\n      email: string,\n      isVerified: boolean,\n      failOnConflict?: boolean,\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.updateEmail, {\n          loginId,\n          email,\n          verified: isVerified,\n          failOnConflict,\n        }),\n        (data) => data.user,\n      ),\n    updatePhone: (\n      loginId: string,\n      phone: string,\n      isVerified: boolean,\n      failOnConflict?: boolean,\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.updatePhone, {\n          loginId,\n          phone,\n          verified: isVerified,\n          failOnConflict,\n        }),\n        (data) => data.user,\n      ),\n    updateDisplayName: (\n      loginId: string,\n      displayName?: string,\n      givenName?: string,\n      middleName?: string,\n      familyName?: string,\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.updateDisplayName, {\n          loginId,\n          displayName,\n          givenName,\n          middleName,\n          familyName,\n        }),\n        (data) => data.user,\n      ),\n    updatePicture: (loginId: string, picture: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.updatePicture, { loginId, picture }),\n        (data) => data.user,\n      ),\n    updateCustomAttribute: (\n      loginId: string,\n      attributeKey: string,\n      attributeValue: AttributesTypes,\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.updateCustomAttribute, {\n          loginId,\n          attributeKey,\n          attributeValue,\n        }),\n        (data) => data.user,\n      ),\n    setRoles: (loginId: string, roles: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.setRole, { loginId, roleNames: roles }),\n        (data) => data.user,\n      ),\n    addRoles: (loginId: string, roles: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.addRole, { loginId, roleNames: roles }),\n        (data) => data.user,\n      ),\n    removeRoles: (loginId: string, roles: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.removeRole, { loginId, roleNames: roles }),\n        (data) => data.user,\n      ),\n    addTenant: (loginId: string, tenantId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.addTenant, { loginId, tenantId }),\n        (data) => data.user,\n      ),\n    removeTenant: (loginId: string, tenantId: string): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.removeTenant, { loginId, tenantId }),\n        (data) => data.user,\n      ),\n    setTenantRoles: (\n      loginId: string,\n      tenantId: string,\n      roles: string[],\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.setRole, { loginId, tenantId, roleNames: roles }),\n        (data) => data.user,\n      ),\n    addTenantRoles: (\n      loginId: string,\n      tenantId: string,\n      roles: string[],\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.addRole, { loginId, tenantId, roleNames: roles }),\n        (data) => data.user,\n      ),\n    removeTenantRoles: (\n      loginId: string,\n      tenantId: string,\n      roles: string[],\n    ): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.removeRole, { loginId, tenantId, roleNames: roles }),\n        (data) => data.user,\n      ),\n    addSSOapps: (loginId: string, ssoAppIds: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.addSSOApps, { loginId, ssoAppIds }),\n        (data) => data.user,\n      ),\n    setSSOapps: (loginId: string, ssoAppIds: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.setSSOApps, { loginId, ssoAppIds }),\n        (data) => data.user,\n      ),\n    removeSSOapps: (loginId: string, ssoAppIds: string[]): Promise<SdkResponse<UserResponse>> =>\n      transformResponse<SingleUserResponse, UserResponse>(\n        httpClient.post(apiPaths.user.removeSSOApps, { loginId, ssoAppIds }),\n        (data) => data.user,\n      ),\n\n    /**\n     * Generate OTP for the given login ID of a test user.\n     * Choose the selected delivery method for verification.\n     * Returns the code for the login (exactly as it sent via Email, SMS, Voice call or WhatsApp)\n     * This is useful when running tests and don't want to use 3rd party messaging services\n     *\n     * @param deliveryMethod optional DeliveryMethod\n     * @param loginId login ID of a test user\n     * @param loginOptions optional LoginOptions - can be provided to set custom claims to the generated jwt.\n     * @returns GenerateOTPForTestResponse which includes the loginId and the OTP code\n     */\n    generateOTPForTestUser: (\n      deliveryMethod: DeliveryMethodForTestUser,\n      loginId: string,\n      loginOptions?: LoginOptions,\n    ): Promise<SdkResponse<GenerateOTPForTestResponse>> =>\n      transformResponse<GenerateOTPForTestResponse>(\n        httpClient.post(apiPaths.user.generateOTPForTest, {\n          deliveryMethod,\n          loginId,\n          loginOptions,\n        }),\n        (data) => data,\n      ),\n\n    /**\n     * Generate Magic Link for the given login ID of a test user.\n     * Choose the selected delivery method for verification.\n     * It returns the link for the login (exactly as it sent via Email)\n     * This is useful when running tests and don't want to use 3rd party messaging services\n     *\n     * @param deliveryMethod optional DeliveryMethod\n     * @param loginId login ID of a test user\n     * @param uri optional redirect uri which will be used instead of any global configuration.\n     * @param loginOptions optional LoginOptions - can be provided to set custom claims to the generated jwt.\n     * @returns GenerateMagicLinkForTestResponse which includes the loginId and the magic link\n     */\n    generateMagicLinkForTestUser: (\n      deliveryMethod: DeliveryMethodForTestUser,\n      loginId: string,\n      uri: string,\n      loginOptions?: LoginOptions,\n    ): Promise<SdkResponse<GenerateMagicLinkForTestResponse>> =>\n      transformResponse<GenerateMagicLinkForTestResponse>(\n        httpClient.post(apiPaths.user.generateMagicLinkForTest, {\n          deliveryMethod,\n          loginId,\n          URI: uri,\n          loginOptions,\n        }),\n        (data) => data,\n      ),\n\n    /**\n     * Generate Enchanted Link for the given login ID of a test user.\n     * It returns the link for the login (exactly as it sent via Email)\n     * and pendingRef which is used to poll for a valid session\n     * This is useful when running tests and don't want to use 3rd party messaging services\n     *\n     * @param loginId login ID of a test user\n     * @param uri optional redirect uri which will be used instead of any global configuration.\n     * @param loginOptions optional LoginOptions - can be provided to set custom claims to the generated jwt.\n     * @returns GenerateEnchantedLinkForTestResponse which includes the loginId, the enchanted link and the pendingRef\n     */\n    generateEnchantedLinkForTestUser: (\n      loginId: string,\n      uri: string,\n      loginOptions?: LoginOptions,\n    ): Promise<SdkResponse<GenerateEnchantedLinkForTestResponse>> =>\n      transformResponse<GenerateEnchantedLinkForTestResponse>(\n        httpClient.post(apiPaths.user.generateEnchantedLinkForTest, {\n          loginId,\n          URI: uri,\n          loginOptions,\n        }),\n        (data) => data,\n      ),\n\n    generateEmbeddedLink: (\n      loginId: string,\n      customClaims?: Record<string, any>,\n      timeout?: number,\n    ): Promise<SdkResponse<GenerateEmbeddedLinkResponse>> =>\n      transformResponse<GenerateEmbeddedLinkResponse>(\n        httpClient.post(apiPaths.user.generateEmbeddedLink, { loginId, customClaims, timeout }),\n        (data) => data,\n      ),\n\n    generateSignUpEmbeddedLink: (\n      loginId: string,\n      user?: {\n        name?: string;\n        givenName?: string;\n        middleName?: string;\n        familyName?: string;\n        phone?: string;\n        email?: string;\n      },\n      emailVerified?: boolean,\n      phoneVerified?: boolean,\n      loginOptions?: LoginOptions,\n      timeout?: number,\n    ): Promise<SdkResponse<GenerateEmbeddedLinkResponse>> =>\n      transformResponse<GenerateEmbeddedLinkResponse>(\n        httpClient.post(apiPaths.user.generateSignUpEmbeddedLink, {\n          loginId,\n          user,\n          emailVerified,\n          phoneVerified,\n          loginOptions,\n          timeout,\n        }),\n        (data) => data,\n      ),\n\n    /**\n     * Set temporary password for the given login ID of user.\n     * Note: The password will automatically be set as expired.\n     * The user will not be able to log-in with this password, and will be required to replace it on next login.\n     * See also: expirePassword\n     * @param loginId The login ID of the user\n     * @param password The password to set for the user\n     */\n    setTemporaryPassword: (loginId: string, password: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        httpClient.post(apiPaths.user.setTemporaryPassword, { loginId, password }),\n        (data) => data,\n      ),\n\n    /**\n     * Set password for the given login ID of user.\n     * @param loginId The login ID of the user\n     * @param password The password to set for the user\n     */\n    setActivePassword: (loginId: string, password: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        httpClient.post(apiPaths.user.setActivePassword, { loginId, password }),\n        (data) => data,\n      ),\n\n    /** Deprecated (user setTemporaryPassword instead)\n     * Set password for the given login ID of user.\n     * Note: The password will automatically be set as expired.\n     * The user will not be able to log-in with this password, and will be required to replace it on next login.\n     * See also: expirePassword\n     * @param loginId The login ID of the user\n     * @param password The password to set for the user\n     */\n    setPassword: (loginId: string, password: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        httpClient.post(apiPaths.user.setPassword, { loginId, password }),\n        (data) => data,\n      ),\n\n    /**\n     * Expire password for the given login ID.\n     * Note: user sign-in with an expired password, the user will get an error with code.\n     * Use the `ResetPassword` or `ReplacePassword` methods to reset/replace the password.\n     * @param loginId The login ID of the user\n     */\n    expirePassword: (loginId: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        httpClient.post(apiPaths.user.expirePassword, { loginId }),\n        (data) => data,\n      ),\n\n    /**\n     * Removes all registered passkeys (WebAuthn devices) for the user with the given login ID.\n     * Note: The user might not be able to login anymore if they have no other authentication\n     * methods or a verified email/phone.\n     * @param loginId The login ID of the user\n     */\n    removeAllPasskeys: (loginId: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        httpClient.post(apiPaths.user.removeAllPasskeys, { loginId }),\n        (data) => data,\n      ),\n\n    /**\n     * Removes TOTP seed for the user with the given login ID.\n     * Note: The user might not be able to login anymore if they have no other authentication\n     * methods or a verified email/phone.\n     * @param loginId The login ID of the user\n     */\n    removeTOTPSeed: (loginId: string): Promise<SdkResponse<never>> =>\n      transformResponse<never>(\n        httpClient.post(apiPaths.user.removeTOTPSeed, { loginId }),\n        (data) => data,\n      ),\n\n    /**\n     * Retrieve users' authentication history, by the given user's ids.\n     * @param userIds The user IDs\n     */\n    history: (userIds: string[]): Promise<SdkResponse<UserHistoryResponse[]>> =>\n      transformResponse<UserHistoryResponse[]>(\n        httpClient.post(apiPaths.user.history, userIds),\n        (data) => data,\n      ),\n  };\n};\n\nexport interface PatchUserOptions {\n  email?: string;\n  phone?: string;\n  displayName?: string;\n  roles?: string[];\n  userTenants?: AssociatedTenant[];\n  customAttributes?: Record<string, AttributesTypes>;\n  picture?: string;\n  verifiedEmail?: boolean;\n  verifiedPhone?: boolean;\n  givenName?: string;\n  middleName?: string;\n  familyName?: string;\n  ssoAppIds?: string[];\n  scim?: boolean;\n  status?: UserStatus;\n}\n\nexport default withUser;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport {\n  CreateTenantResponse,\n  Tenant,\n  AttributesTypes,\n  TenantSettings,\n  GenerateSSOConfigurationLinkResponse,\n} from './types';\n\ntype MultipleTenantResponse = {\n  tenants: Tenant[];\n};\n\nconst withTenant = (httpClient: HttpClient) => ({\n  create: (\n    name: string,\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n    enforceSSO?: boolean,\n    disabled?: boolean,\n    parent?: string,\n  ): Promise<SdkResponse<CreateTenantResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.tenant.create, {\n        name,\n        selfProvisioningDomains,\n        customAttributes,\n        enforceSSO,\n        disabled,\n        parent,\n      }),\n    ),\n  createWithId: (\n    id: string,\n    name: string,\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n    enforceSSO?: boolean,\n    disabled?: boolean,\n    parent?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.tenant.create, {\n        id,\n        name,\n        selfProvisioningDomains,\n        customAttributes,\n        enforceSSO,\n        disabled,\n        parent,\n      }),\n    ),\n  update: (\n    id: string,\n    name: string,\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n    enforceSSO?: boolean,\n    disabled?: boolean,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.tenant.update, {\n        id,\n        name,\n        selfProvisioningDomains,\n        customAttributes,\n        enforceSSO,\n        disabled,\n      }),\n    ),\n  delete: (id: string, cascade?: boolean): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.tenant.delete, { id, cascade })),\n  load: (id: string): Promise<SdkResponse<Tenant>> =>\n    transformResponse<Tenant, Tenant>(\n      httpClient.get(apiPaths.tenant.load, {\n        queryParams: { id },\n      }),\n      (data) => data,\n    ),\n  loadAll: (): Promise<SdkResponse<Tenant[]>> =>\n    transformResponse<MultipleTenantResponse, Tenant[]>(\n      httpClient.get(apiPaths.tenant.loadAll, {}),\n      (data) => data.tenants,\n    ),\n  searchAll: (\n    ids?: string[],\n    names?: string[],\n    selfProvisioningDomains?: string[],\n    customAttributes?: Record<string, AttributesTypes>,\n    parentTenantId?: string,\n  ): Promise<SdkResponse<Tenant[]>> =>\n    transformResponse<MultipleTenantResponse, Tenant[]>(\n      httpClient.post(apiPaths.tenant.searchAll, {\n        tenantIds: ids,\n        tenantNames: names,\n        tenantSelfProvisioningDomains: selfProvisioningDomains,\n        customAttributes,\n        parentTenantId,\n      }),\n      (data) => data.tenants,\n    ),\n  getSettings: (tenantId: string): Promise<SdkResponse<TenantSettings>> =>\n    transformResponse<TenantSettings, TenantSettings>(\n      httpClient.get(apiPaths.tenant.settings, {\n        queryParams: { id: tenantId },\n      }),\n      (data) => data,\n    ),\n  configureSettings: (tenantId: string, settings: TenantSettings): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.tenant.settings, { ...settings, tenantId }, {})),\n  generateSSOConfigurationLink: (\n    tenantId: string,\n    expireDuration: number,\n    ssoId?: string,\n    email?: string,\n    templateId?: string,\n  ): Promise<SdkResponse<GenerateSSOConfigurationLinkResponse>> =>\n    transformResponse<GenerateSSOConfigurationLinkResponse, GenerateSSOConfigurationLinkResponse>(\n      httpClient.post(\n        apiPaths.tenant.generateSSOConfigurationLink,\n        { tenantId, expireTime: expireDuration, ssoId, email, templateId },\n        {},\n      ),\n      (data) => data,\n    ),\n});\n\nexport default withTenant;\n","import { JWTResponse, SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport {\n  MgmtLoginOptions,\n  MgmtSignUpOptions,\n  MgmtUserOptions,\n  UpdateJWTResponse,\n  ClientAssertionResponse,\n} from './types';\n\ntype AnonymousJWTResponse = Omit<JWTResponse, 'user' | 'firstSeen'>;\n\nconst withJWT = (httpClient: HttpClient) => ({\n  update: (\n    jwt: string,\n    customClaims?: Record<string, any>,\n    refreshDuration?: number,\n  ): Promise<SdkResponse<UpdateJWTResponse>> =>\n    transformResponse(httpClient.post(apiPaths.jwt.update, { jwt, customClaims, refreshDuration })),\n  impersonate: (\n    impersonatorId: string,\n    loginId: string,\n    validateConsent: boolean,\n    customClaims?: Record<string, any>,\n    selectedTenant?: string,\n    refreshDuration?: number,\n  ): Promise<SdkResponse<UpdateJWTResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.jwt.impersonate, {\n        impersonatorId,\n        loginId,\n        validateConsent,\n        customClaims,\n        selectedTenant,\n        refreshDuration,\n      }),\n    ),\n  stopImpersonation: (\n    jwt: string,\n    customClaims?: Record<string, any>,\n    selectedTenant?: string,\n    refreshDuration?: number,\n  ): Promise<SdkResponse<UpdateJWTResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.jwt.stopImpersonation, {\n        jwt,\n        customClaims,\n        selectedTenant,\n        refreshDuration,\n      }),\n    ),\n  signIn: (loginId: string, loginOptions?: MgmtLoginOptions): Promise<SdkResponse<JWTResponse>> =>\n    transformResponse(httpClient.post(apiPaths.jwt.signIn, { loginId, ...loginOptions })),\n  signUp: (\n    loginId: string,\n    user?: MgmtUserOptions,\n    signUpOptions?: MgmtSignUpOptions,\n  ): Promise<SdkResponse<JWTResponse>> =>\n    transformResponse(httpClient.post(apiPaths.jwt.signUp, { loginId, user, ...signUpOptions })),\n  signUpOrIn: (\n    loginId: string,\n    user?: MgmtUserOptions,\n    signUpOptions?: MgmtSignUpOptions,\n  ): Promise<SdkResponse<JWTResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.jwt.signUpOrIn, { loginId, user, ...signUpOptions }),\n    ),\n  anonymous: (\n    customClaims?: Record<string, any>,\n    selectedTenant?: string,\n    refreshDuration?: number,\n  ): Promise<SdkResponse<AnonymousJWTResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.jwt.anonymous, { customClaims, selectedTenant, refreshDuration }),\n    ),\n  generateClientAssertionJwt: (\n    issuer: string,\n    subject: string,\n    audience: string[],\n    expiresIn: number,\n    flattenAudience?: boolean,\n    algorithm?: 'RS256' | 'RS384' | 'ES384',\n  ): Promise<SdkResponse<ClientAssertionResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.jwt.clientAssertion, {\n        issuer,\n        subject,\n        audience,\n        expiresIn,\n        flattenAudience,\n        algorithm,\n      }),\n    ),\n});\n\nexport default withJWT;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport { Permission } from './types';\n\ntype MultiplePermissionResponse = {\n  permissions: Permission[];\n};\n\nconst withPermission = (httpClient: HttpClient) => ({\n  create: (name: string, description?: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.permission.create, { name, description })),\n  update: (name: string, newName: string, description?: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.permission.update, { name, newName, description })),\n  delete: (name: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.permission.delete, { name })),\n  loadAll: (): Promise<SdkResponse<Permission[]>> =>\n    transformResponse<MultiplePermissionResponse, Permission[]>(\n      httpClient.get(apiPaths.permission.loadAll, {}),\n      (data) => data.permissions,\n    ),\n});\n\nexport default withPermission;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport { Role, RoleSearchOptions } from './types';\n\ntype MultipleRoleResponse = {\n  roles: Role[];\n};\n\nconst withRole = (httpClient: HttpClient) => ({\n  create: (\n    name: string,\n    description?: string,\n    permissionNames?: string[],\n    tenantId?: string,\n    defaultRole?: boolean,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.role.create, {\n        name,\n        description,\n        permissionNames,\n        tenantId,\n        default: defaultRole,\n      }),\n    ),\n  update: (\n    name: string,\n    newName: string,\n    description?: string,\n    permissionNames?: string[],\n    tenantId?: string,\n    defaultRole?: boolean,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.role.update, {\n        name,\n        newName,\n        description,\n        permissionNames,\n        tenantId,\n        default: defaultRole,\n      }),\n    ),\n  delete: (name: string, tenantId?: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.role.delete, { name, tenantId })),\n  loadAll: (): Promise<SdkResponse<Role[]>> =>\n    transformResponse<MultipleRoleResponse, Role[]>(\n      httpClient.get(apiPaths.role.loadAll, {}),\n      (data) => data.roles,\n    ),\n  search: (options: RoleSearchOptions): Promise<SdkResponse<Role[]>> =>\n    transformResponse<MultipleRoleResponse, Role[]>(\n      httpClient.post(apiPaths.role.search, options, {}),\n      (data) => data.roles,\n    ),\n});\n\nexport default withRole;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport { Group } from './types';\n\nconst withGroup = (httpClient: HttpClient) => ({\n  /**\n   * Load all groups for a specific tenant id.\n   * @param tenantId Tenant ID to load groups from.\n   * @returns Group[] list of groups\n   */\n  loadAllGroups: (tenantId: string): Promise<SdkResponse<Group[]>> =>\n    transformResponse<Group[]>(httpClient.post(apiPaths.group.loadAllGroups, { tenantId })),\n\n  /**\n   * Load all groups for the provided user IDs or login IDs.\n   * @param tenantId Tenant ID to load groups from.\n   * @param userIds Optional List of user IDs, with the format of \"U2J5ES9S8TkvCgOvcrkpzUgVTEBM\" (example), which can be found on the user's JWT.\n   * @param loginIds Optional List of login IDs, how the user identifies when logging in.\n   * @returns Group[] list of groups\n   */\n  loadAllGroupsForMember: (\n    tenantId: string,\n    userIds: string[],\n    loginIds: string[],\n  ): Promise<SdkResponse<Group[]>> =>\n    transformResponse<Group[]>(\n      httpClient.post(apiPaths.group.loadAllGroupsForMember, { tenantId, loginIds, userIds }),\n    ),\n\n  /**\n   * Load all members of the provided group id.\n   * @param tenantId Tenant ID to load groups from.\n   * @param groupId Group ID to load members for.\n   * @returns Group[] list of groups\n   */\n  loadAllGroupMembers: (tenantId: string, groupId: string): Promise<SdkResponse<Group[]>> =>\n    transformResponse<Group[]>(\n      httpClient.post(apiPaths.group.loadAllGroupMembers, { tenantId, groupId }),\n    ),\n});\n\nexport default withGroup;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport {\n  RoleMappings,\n  AttributeMapping,\n  SSOSettingsResponse,\n  SSOOIDCSettings,\n  SSOSAMLSettings,\n  SSOSAMLByMetadataSettings,\n  SSOSettings,\n} from './types';\n\nfunction transformSettingsResponse(data) {\n  const readySettings = data as any;\n  if (readySettings.oidc) {\n    readySettings.oidc = {\n      ...readySettings.oidc,\n      attributeMapping: readySettings.oidc.userAttrMapping,\n    };\n    delete readySettings.oidc.userAttrMapping;\n  }\n  if (readySettings.saml?.groupsMapping) {\n    readySettings.saml.groupsMapping = readySettings.saml?.groupsMapping.map((gm: any) => {\n      const rm = gm;\n      rm.roleName = rm.role.name;\n      delete rm.role;\n      return rm;\n    });\n  }\n  return readySettings;\n}\n\nfunction transformAllSettingsResponse(data) {\n  const readySettings = data.SSOSettings as any[];\n  const res = [];\n  readySettings.forEach((setting) => res.push(transformSettingsResponse(setting)));\n  return res;\n}\n\nconst withSSOSettings = (httpClient: HttpClient) => ({\n  /**\n   * @deprecated  Use loadSettings instead\n   */\n  getSettings: (tenantId: string): Promise<SdkResponse<SSOSettingsResponse>> =>\n    transformResponse<SSOSettingsResponse>(\n      httpClient.get(apiPaths.sso.settings, {\n        queryParams: { tenantId },\n      }),\n      (data) => data,\n    ),\n  newSettings: (\n    tenantId: string,\n    ssoId: string,\n    displayName: string,\n  ): Promise<SdkResponse<SSOSettings>> =>\n    transformResponse<SSOSettings>(\n      httpClient.post(apiPaths.sso.settingsNew, {\n        tenantId,\n        ...(ssoId ? { ssoId } : {}),\n        displayName,\n      }),\n      (data) => transformSettingsResponse(data),\n    ),\n  deleteSettings: (tenantId: string, ssoId?: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.delete(apiPaths.sso.settings, {\n        queryParams: { tenantId, ...(ssoId ? { ssoId } : {}) },\n      }),\n    ),\n  /**\n   * @deprecated  Use configureSAMLSettings or configureOIDCSettings instead\n   */\n  configureSettings: (\n    tenantId: string,\n    idpURL: string,\n    idpCert: string,\n    entityId: string,\n    redirectURL: string,\n    domains: string[],\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.sso.settings, {\n        tenantId,\n        idpURL,\n        entityId,\n        idpCert,\n        redirectURL,\n        domains,\n      }),\n    ),\n  /**\n   * @deprecated  Use configureSAMLByMetadata instead\n   */\n  configureMetadata: (\n    tenantId: string,\n    idpMetadataURL: string,\n    redirectURL: string,\n    domains: string[],\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.sso.metadata, { tenantId, idpMetadataURL, redirectURL, domains }),\n    ),\n  /**\n   * @deprecated  Use configureSAMLSettings, configureSAMLByMetadata or configureOIDCSettings instead\n   */\n  configureMapping: (\n    tenantId: string,\n    roleMappings?: RoleMappings,\n    attributeMapping?: AttributeMapping,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.sso.mapping, { tenantId, roleMappings, attributeMapping }),\n    ),\n  configureOIDCSettings: (\n    tenantId: string,\n    settings: SSOOIDCSettings,\n    domains?: string[],\n    ssoId?: string,\n  ): Promise<SdkResponse<never>> => {\n    const readySettings = { ...settings, userAttrMapping: settings.attributeMapping };\n    delete readySettings.attributeMapping;\n    return transformResponse(\n      httpClient.post(apiPaths.sso.oidc.configure, {\n        tenantId,\n        settings: readySettings,\n        domains,\n        ...(ssoId ? { ssoId } : {}),\n      }),\n    );\n  },\n  configureSAMLSettings: (\n    tenantId: string,\n    settings: SSOSAMLSettings,\n    redirectUrl?: string,\n    domains?: string[],\n    ssoId?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.sso.saml.configure, {\n        tenantId,\n        settings,\n        redirectUrl,\n        domains,\n        ...(ssoId ? { ssoId } : {}),\n      }),\n    ),\n  configureSAMLByMetadata: (\n    tenantId: string,\n    settings: SSOSAMLByMetadataSettings,\n    redirectUrl?: string,\n    domains?: string[],\n    ssoId?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.sso.saml.metadata, {\n        tenantId,\n        settings,\n        redirectUrl,\n        domains,\n        ...(ssoId ? { ssoId } : {}),\n      }),\n    ),\n  loadSettings: (tenantId: string, ssoId?: string): Promise<SdkResponse<SSOSettings>> =>\n    transformResponse<SSOSettings>(\n      httpClient.get(apiPaths.sso.settingsv2, {\n        queryParams: { tenantId, ...(ssoId ? { ssoId } : {}) },\n      }),\n      (data) => transformSettingsResponse(data),\n    ),\n  loadAllSettings: (tenantId: string): Promise<SdkResponse<SSOSettings[]>> =>\n    transformResponse<SSOSettings[]>(\n      httpClient.get(apiPaths.sso.settingsAllV2, {\n        queryParams: { tenantId },\n      }),\n      (data) => transformAllSettingsResponse(data),\n    ),\n});\n\nexport default withSSOSettings;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport { AccessKey, AssociatedTenant, CreatedAccessKeyResponse } from './types';\n\ntype SingleKeyResponse = {\n  key: AccessKey;\n};\n\ntype MultipleKeysResponse = {\n  keys: AccessKey[];\n};\n\nconst withAccessKey = (httpClient: HttpClient) => ({\n  /**\n   * Create a new access key for a project.\n   * @param name Access key name\n   * @param expireTime When the access key expires. Keep at 0 to make it indefinite.\n   * @param roles Optional roles in the project. Does not apply for multi-tenants\n   * @param tenants Optional associated tenants for this key and its roles for each.\n   * @param userId Optional bind this access key to a specific user.\n   * @param customClaims Optional map of claims and their values that will be present in the JWT.\n   * @param description Optional free text description\n   * @param permittedIps Optional list of IP addresses or CIDR ranges that are allowed to use this access key.\n   * @returns A newly created key and its cleartext. Make sure to save the cleartext securely.\n   */\n  create: (\n    name: string,\n    expireTime: number,\n    roles?: string[],\n    tenants?: AssociatedTenant[],\n    userId?: string,\n    customClaims?: Record<string, any>,\n    description?: string,\n    permittedIps?: string[],\n  ): Promise<SdkResponse<CreatedAccessKeyResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.accessKey.create, {\n        name,\n        expireTime,\n        roleNames: roles,\n        keyTenants: tenants,\n        userId,\n        customClaims,\n        description,\n        permittedIps,\n      }),\n    ),\n  /**\n   * Load an access key.\n   * @param id Access key ID to load\n   * @returns The loaded access key.\n   */\n  load: (id: string): Promise<SdkResponse<AccessKey>> =>\n    transformResponse<SingleKeyResponse, AccessKey>(\n      httpClient.get(apiPaths.accessKey.load, {\n        queryParams: { id },\n      }),\n      (data) => data.key,\n    ),\n  /**\n   * Search all access keys\n   * @param tenantIds Optional tenant ID filter to apply on the search results\n   * @returns An array of found access keys\n   */\n  searchAll: (tenantIds?: string[]): Promise<SdkResponse<AccessKey[]>> =>\n    transformResponse<MultipleKeysResponse, AccessKey[]>(\n      httpClient.post(apiPaths.accessKey.search, { tenantIds }),\n      (data) => data.keys,\n    ),\n  /**\n   * Update an access key.\n   * @param id Access key ID to load\n   * @param name The updated access key name\n   * @param description Optional updated access key description\n   * @param roles Optional roles in the project. Does not apply for multi-tenants\n   * @param tenants Optional associated tenants for this key and its roles for each.\n   * @param customClaims Optional map of claims and their values that will be present in the JWT.\n   * @param permittedIps Optional list of IP addresses or CIDR ranges that are allowed to use this access key.\n   * @returns The updated access key\n   */\n  update: (\n    id: string,\n    name: string,\n    description?: string,\n    roles?: string[],\n    tenants?: AssociatedTenant[],\n    customClaims?: Record<string, any>,\n    permittedIps?: string[],\n  ): Promise<SdkResponse<AccessKey>> =>\n    transformResponse<SingleKeyResponse, AccessKey>(\n      httpClient.post(apiPaths.accessKey.update, {\n        id,\n        name,\n        description,\n        roleNames: roles,\n        keyTenants: tenants,\n        customClaims,\n        permittedIps,\n      }),\n      (data) => data.key,\n    ),\n  /**\n   * Deactivate an access key. Deactivated access keys cannot be used until they are\n   * activated again.\n   * @param id Access key ID to deactivate\n   */\n  deactivate: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.accessKey.deactivate, { id })),\n  /**\n   * Activate an access key. Only deactivated access keys can be activated again.\n   * @param id Access key ID to activate\n   */\n  activate: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.accessKey.activate, { id })),\n  /**\n   * Delete an access key. IMPORTANT: This cannot be undone. Use carefully.\n   * @param id Access key ID to delete\n   */\n  delete: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.accessKey.delete, { id })),\n});\n\nexport default withAccessKey;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport {\n  FlowResponse,\n  FlowsResponse,\n  Screen,\n  Flow,\n  ManagementFlowOptions,\n  RunManagementFlowResponse,\n} from './types';\n\nconst WithFlow = (httpClient: HttpClient) => ({\n  list: (): Promise<SdkResponse<FlowsResponse>> =>\n    transformResponse(httpClient.post(apiPaths.flow.list, {})),\n  delete: (flowIds: string[]): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.flow.delete, { ids: flowIds })),\n  export: (flowId: string): Promise<SdkResponse<FlowResponse>> =>\n    transformResponse(httpClient.post(apiPaths.flow.export, { flowId })),\n  import: (flowId: string, flow: Flow, screens?: Screen[]): Promise<SdkResponse<FlowResponse>> =>\n    transformResponse(httpClient.post(apiPaths.flow.import, { flowId, flow, screens })),\n  run: (\n    flowId: string,\n    options?: ManagementFlowOptions,\n  ): Promise<SdkResponse<RunManagementFlowResponse['output']>> =>\n    transformResponse(\n      httpClient.post(apiPaths.flow.run, { flowId, options }),\n      (data) => (data as RunManagementFlowResponse)?.output,\n    ),\n});\n\nexport default WithFlow;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport { Theme, ThemeResponse } from './types';\n\nconst WithTheme = (httpClient: HttpClient) => ({\n  export: (): Promise<SdkResponse<ThemeResponse>> =>\n    transformResponse(httpClient.post(apiPaths.theme.export, {})),\n  import: (theme: Theme): Promise<SdkResponse<ThemeResponse>> =>\n    transformResponse(httpClient.post(apiPaths.theme.import, { theme })),\n});\n\nexport default WithTheme;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport { AuditSearchOptions, AuditRecord, AuditCreateOptions } from './types';\n\nconst WithAudit = (httpClient: HttpClient) => ({\n  /**\n   * Search the audit trail for up to last 30 days based on given optional parameters\n   * @param searchOptions to filter which audit records to return\n   * @returns the audit records array\n   */\n  search: (searchOptions: AuditSearchOptions): Promise<SdkResponse<AuditRecord[]>> => {\n    const body = { ...searchOptions, externalIds: searchOptions.loginIds };\n    delete body.loginIds;\n    return transformResponse(httpClient.post(apiPaths.audit.search, body), (data) =>\n      data?.audits.map((a) => {\n        const res = {\n          ...a,\n          occurred: parseFloat(a.occurred),\n          loginIds: a.externalIds,\n        };\n        delete res.externalIds;\n        return res;\n      }),\n    );\n  },\n  /**\n   * Create audit event\n   * @param createOptions to define which audit event to create\n   * @returns the audit records array\n   */\n  createEvent: (createOptions: AuditCreateOptions): Promise<SdkResponse<never>> => {\n    const body = { ...createOptions };\n    return transformResponse(httpClient.post(apiPaths.audit.createEvent, body));\n  },\n});\n\nexport default WithAudit;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport {\n  AuthzSchema,\n  AuthzNamespace,\n  AuthzRelationDefinition,\n  AuthzRelation,\n  AuthzRelationQuery,\n  AuthzModified,\n  AuthzResource,\n} from './types';\n\nconst WithAuthz = (httpClient: HttpClient) => ({\n  /**\n   * Save (create or update) the given schema.\n   * In case of update, will update only given namespaces and will not delete namespaces unless upgrade flag is true.\n   * Schema name can be used for projects to track versioning.\n   *\n   * @param schema the schema to save\n   * @param upgrade should we upgrade existing schema or ignore any namespace not provided\n   * @returns standard success or failure response\n   */\n  saveSchema: (schema: AuthzSchema, upgrade: boolean): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.authz.schemaSave, { schema, upgrade })),\n  /**\n   * Delete the schema for the project which will also delete all relations.\n   *\n   * @returns standard success or failure response\n   */\n  deleteSchema: (): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.authz.schemaDelete, {})),\n  /**\n   * Load the schema for the project.\n   *\n   * @returns the schema associated with the project\n   */\n  loadSchema: (): Promise<SdkResponse<AuthzSchema>> =>\n    transformResponse(httpClient.post(apiPaths.authz.schemaLoad, {}), (data) => data.schema),\n  /**\n   * Save (create or update) the given namespace.\n   * Will not delete relation definitions not mentioned in the namespace.\n   *\n   * @param namespace the namespace to save\n   * @param oldName if we are changing the namespace name, what was the old name we are updating.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  saveNamespace: (\n    namespace: AuthzNamespace,\n    oldName?: string,\n    schemaName?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.authz.nsSave, { namespace, oldName, schemaName })),\n  /**\n   * Delete the given namespace.\n   * Will also delete the relevant relations.\n   *\n   * @param name to delete.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  deleteNamespace: (name: string, schemaName?: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.authz.nsDelete, { name, schemaName })),\n  /**\n   * Save (create or update) the given relation definition.\n   *\n   * @param relationDefinition rd to save.\n   * @param namespace that it belongs to.\n   * @param oldName if we are changing the relation definition name, what was the old name we are updating.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  saveRelationDefinition: (\n    relationDefinition: AuthzRelationDefinition,\n    namespace: string,\n    oldName?: string,\n    schemaName?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.authz.rdSave, {\n        relationDefinition,\n        namespace,\n        oldName,\n        schemaName,\n      }),\n    ),\n  /**\n   * Delete the given relation definition.\n   * Will also delete the relevant relations.\n   *\n   * @param name to delete.\n   * @param namespace it belongs to.\n   * @param schemaName optional and used to track the current schema version.\n   * @returns standard success or failure response\n   */\n  deleteRelationDefinition: (\n    name: string,\n    namespace: string,\n    schemaName?: string,\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.authz.rdDelete, { name, namespace, schemaName })),\n  /**\n   * Create the given relations.\n   *\n   * @param relations to create.\n   * @returns standard success or failure response\n   */\n  createRelations: (relations: AuthzRelation[]): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.authz.reCreate, { relations })),\n  /**\n   * Delete the given relations.\n   *\n   * @param relations to delete.\n   * @returns standard success or failure response\n   */\n  deleteRelations: (relations: AuthzRelation[]): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.authz.reDelete, { relations })),\n  /**\n   * @deprecated use `deleteRelationsForIds` instead for better clarity\n   *\n   * Delete any relations with matching resourceIds OR targetIds\n   *\n   * @param resources ids to delete relations for.\n   * @returns standard success or failure response\n   */\n  deleteRelationsForResources: (resources: string[]): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.authz.reDeleteResources, { resources })),\n  /**\n   *\n   * Delete any relations with matching resourceIds\n   *\n   * @param resources resource ids to delete relations for.\n   * @returns\n   */\n  deleteResourceRelationsForResources: (resources: string[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.authz.reDeleteResourceRelationsForResources, { resources }),\n    ),\n  /**\n   * Delete any relations with matching resourceIds OR targetIds\n   *\n   * @param ids ids to delete relations for.\n   * @returns standard success or failure response\n   */\n  deleteRelationsForIds: (ids: string[]): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.authz.reDeleteResources, { resources: ids })),\n  /**\n   * Query relations to see what relations exists.\n   *\n   * @param relationQueries array of relation queries to check.\n   * @returns array of relation query responses with the boolean flag indicating if relation exists\n   */\n  hasRelations: (\n    relationQueries: AuthzRelationQuery[],\n  ): Promise<SdkResponse<AuthzRelationQuery[]>> =>\n    transformResponse(\n      httpClient.post(apiPaths.authz.hasRelations, { relationQueries }),\n      (data) => data.relationQueries,\n    ),\n  /**\n   * List all the users that have the given relation definition to the given resource.\n   *\n   * @param resource The resource we are checking\n   * @param relationDefinition The relation definition we are querying\n   * @param namespace The namespace for the relation definition\n   * @returns array of users who have the given relation definition\n   */\n  whoCanAccess: (\n    resource: string,\n    relationDefinition: string,\n    namespace: string,\n  ): Promise<SdkResponse<string[]>> =>\n    transformResponse(\n      httpClient.post(apiPaths.authz.who, { resource, relationDefinition, namespace }),\n      (data) => data.targets,\n    ),\n  /**\n   * Return the list of all defined relations (not recursive) on the given resource.\n   *\n   * @param resource The resource we are checking\n   * @param ignoreTargetSetRelations if true, will not return target set relations even if they exist\n   * @returns array of relations that exist for the given resource\n   */\n  resourceRelations: (\n    resource: string,\n    ignoreTargetSetRelations = false,\n  ): Promise<SdkResponse<AuthzRelation[]>> =>\n    transformResponse(\n      httpClient.post(apiPaths.authz.resource, { resource, ignoreTargetSetRelations }),\n      (data) => data.relations,\n    ),\n  /**\n   * Return the list of all defined relations (not recursive) for the given targets.\n   *\n   * @param targets array of targets we want to check\n   * @param includeTargetSetRelations if true, will include target set relations as well as target relations\n   * @returns array of relations that exist for the given targets\n   */\n  targetsRelations: (\n    targets: string[],\n    includeTargetSetRelations = false,\n  ): Promise<SdkResponse<AuthzRelation[]>> =>\n    transformResponse(\n      httpClient.post(apiPaths.authz.targets, { targets, includeTargetSetRelations }),\n      (data) => data.relations,\n    ),\n  /**\n   * Return the list of all relations for the given target including derived relations from the schema tree.\n   *\n   * @param target The target to check relations for\n   * @returns array of relations that exist for the given targets\n   */\n  whatCanTargetAccess: (target: string): Promise<SdkResponse<AuthzRelation[]>> =>\n    transformResponse(\n      httpClient.post(apiPaths.authz.targetAll, { target }),\n      (data) => data.relations,\n    ),\n\n  /**\n   * Return all resources which the target can access via relation paths that end with the given relation definition\n   *\n   * @param target The target to check resource access for, e.g. user:123\n   * @param relationDefinition A relation on a resource, e.g. owner\n   * @param namespace The namespace (type) of the resource in which the relation is defined, e.g. folder\n   * @returns array of resources that the target can access on relation paths which include the given relation definition\n   */\n  whatCanTargetAccessWithRelation: (\n    target: string,\n    relationDefinition: string,\n    namespace: string,\n  ): Promise<SdkResponse<AuthzResource[]>> =>\n    transformResponse(\n      httpClient.post(apiPaths.authz.targetWithRelation, { target, relationDefinition, namespace }),\n      (data) => data.resources.map((resource: string) => ({ resource })),\n    ),\n\n  /**\n   * Return the list of all relations for the given target including derived relations from the schema tree.\n   *\n   * @param target The target to check relations for\n   * @returns array of relations that exist for the given targets\n   */\n  getModified: (since: Date): Promise<SdkResponse<AuthzModified>> =>\n    transformResponse(\n      httpClient.post(apiPaths.authz.getModified, { since: since ? since.getTime() : 0 }),\n      (data) => data as AuthzModified,\n    ),\n});\n\nexport default WithAuthz;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport {\n  CreateSSOApplicationResponse,\n  SSOApplication,\n  OidcApplicationOptions,\n  SamlApplicationOptions,\n} from './types';\n\ntype MultipleSSOApplicationResponse = {\n  apps: SSOApplication[];\n};\n\nconst withSSOApplication = (httpClient: HttpClient) => ({\n  createOidcApplication: (\n    options: OidcApplicationOptions,\n  ): Promise<SdkResponse<CreateSSOApplicationResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.ssoApplication.oidcCreate, {\n        ...options,\n        enabled: options.enabled ?? true,\n      }),\n    ),\n  createSamlApplication: (\n    options: SamlApplicationOptions,\n  ): Promise<SdkResponse<CreateSSOApplicationResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.ssoApplication.samlCreate, {\n        ...options,\n        enabled: options.enabled ?? true,\n      }),\n    ),\n  updateOidcApplication: (\n    options: OidcApplicationOptions & { id: string },\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.ssoApplication.oidcUpdate, { ...options })),\n  updateSamlApplication: (\n    options: SamlApplicationOptions & { id: string },\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.ssoApplication.samlUpdate, { ...options })),\n  delete: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.ssoApplication.delete, { id })),\n  load: (id: string): Promise<SdkResponse<SSOApplication>> =>\n    transformResponse<SSOApplication, SSOApplication>(\n      httpClient.get(apiPaths.ssoApplication.load, {\n        queryParams: { id },\n      }),\n      (data) => data,\n    ),\n  loadAll: (): Promise<SdkResponse<SSOApplication[]>> =>\n    transformResponse<MultipleSSOApplicationResponse, SSOApplication[]>(\n      httpClient.get(apiPaths.ssoApplication.loadAll, {}),\n      (data) => data.apps,\n    ),\n});\n\nexport default withSSOApplication;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport { PasswordSettings } from './types';\n\nconst withPassword = (httpClient: HttpClient) => ({\n  getSettings: (tenantId: string): Promise<SdkResponse<PasswordSettings>> =>\n    transformResponse<PasswordSettings, PasswordSettings>(\n      httpClient.get(apiPaths.password.settings, {\n        queryParams: { tenantId },\n      }),\n      (data) => data,\n    ),\n  configureSettings: (tenantId: string, settings: PasswordSettings): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.password.settings, { ...settings, tenantId })),\n});\n\nexport default withPassword;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport fetch from '../fetch-polyfill';\nimport apiPaths from './paths';\nimport {\n  CheckResponseRelation,\n  FGARelation,\n  FGASchema,\n  FGAResourceDetails,\n  FGAResourceIdentifier,\n  FGAConfig,\n} from './types';\n\nconst DEFAULT_CACHE_TIMEOUT_MS = 5000;\n\nconst WithFGA = (httpClient: HttpClient, config?: FGAConfig) => {\n  const postWithOptionalCache = async (path: string, body: unknown): Promise<Response> => {\n    if (config?.fgaCacheUrl && config.managementKey) {\n      const url = `${config.fgaCacheUrl}${path}`;\n\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), DEFAULT_CACHE_TIMEOUT_MS);\n\n        const response = await fetch(url, {\n          method: 'POST',\n          headers: {\n            ...config.headers,\n            'Content-Type': 'application/json',\n            Authorization: `Bearer ${config.projectId}:${config.managementKey}`,\n            'x-descope-project-id': config.projectId,\n          },\n          body: JSON.stringify(body),\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n        return response;\n      } catch {\n        return httpClient.post(path, body);\n      }\n    }\n    return httpClient.post(path, body);\n  };\n\n  return {\n    /**\n     * Save (create or update) the given schema.\n     * In case of update, will update only given namespaces and will not delete namespaces unless upgrade flag is true.\n     *\n     * @param schema the schema to save\n     * @returns standard success or failure response\n     */\n    saveSchema: (schema: FGASchema): Promise<SdkResponse<never>> =>\n      transformResponse(postWithOptionalCache(apiPaths.fga.schema, schema)),\n    /**\n     * Delete the schema for the project which will also delete all relations.\n     *\n     * @returns standard success or failure response\n     */\n    deleteSchema: (): Promise<SdkResponse<never>> =>\n      transformResponse(httpClient.post(apiPaths.authz.schemaDelete, {})),\n    /**\n     * Create the given relations.\n     *\n     * @param relations to create.\n     * @returns standard success or failure response\n     */\n    createRelations: (relations: FGARelation[]): Promise<SdkResponse<never>> =>\n      transformResponse(postWithOptionalCache(apiPaths.fga.relations, { tuples: relations })),\n\n    /**\n     * Delete the given relations.\n     * This is a bulk operation and will delete all the given relations.\n     *\n     * @param relations to delete.\n     * @returns standard success or failure response\n     */\n\n    deleteRelations: (relations: FGARelation[]): Promise<SdkResponse<never>> =>\n      transformResponse(postWithOptionalCache(apiPaths.fga.deleteRelations, { tuples: relations })),\n\n    /**\n     * Check if the given relations exist.\n     * This is a read-only operation and will not create any relations.\n     * It will return the relations with the boolean flag indicating if relation exists.\n     * This is useful to check if a relation exists before creating it.\n     *\n     * @param relations to check.\n     * @returns array of relations with the boolean flag indicating if relation exists\n     */\n    check: (relations: FGARelation[]): Promise<SdkResponse<CheckResponseRelation[]>> =>\n      transformResponse(\n        postWithOptionalCache(apiPaths.fga.check, { tuples: relations }),\n        (data) => data.tuples,\n      ),\n\n    /**\n     * Load details for the given resource identifiers.\n     * @param resourceIdentifiers the resource identifiers (resourceId and resourceType tuples) to load details for\n     */\n    loadResourcesDetails: (\n      resourceIdentifiers: FGAResourceIdentifier[],\n    ): Promise<SdkResponse<FGAResourceDetails[]>> =>\n      transformResponse(\n        httpClient.post(apiPaths.fga.resourcesLoad, { resourceIdentifiers }),\n        (data) => data.resourcesDetails,\n      ),\n\n    /**\n     * Save details for the given resources.\n     * @param resourcesDetails the resources details to save\n     */\n    saveResourcesDetails: (resourcesDetails: FGAResourceDetails[]): Promise<SdkResponse<never>> =>\n      transformResponse(httpClient.post(apiPaths.fga.resourcesSave, { resourcesDetails })),\n\n    /**\n     * Delete all relations.\n     *\n     * @returns standard success or failure response\n     */\n    deleteAllRelations: (): Promise<SdkResponse<never>> =>\n      transformResponse(httpClient.delete(apiPaths.fga.relations)),\n  };\n};\n\nexport default WithFGA;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport {\n  InboundApplication,\n  InboundApplicationConsent,\n  InboundApplicationConsentDeleteOptions,\n  InboundApplicationConsentSearchOptions,\n  CreateInboundApplicationResponse,\n  InboundApplicationOptions,\n  InboundApplicationSecretResponse,\n} from './types';\n\ntype MultipleInboundApplicationResponse = {\n  apps: InboundApplication[];\n};\n\ntype MultipleInboundApplicationConsentsResponse = {\n  consents: InboundApplicationConsent[];\n};\n\nconst withInboundApplication = (httpClient: HttpClient) => ({\n  createApplication: (\n    options: InboundApplicationOptions,\n  ): Promise<SdkResponse<CreateInboundApplicationResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.inboundApplication.create, {\n        ...options,\n      }),\n    ),\n  updateApplication: (\n    options: InboundApplicationOptions & { id: string },\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.inboundApplication.update, { ...options })),\n  patchApplication: (\n    options: Partial<InboundApplicationOptions> & { id: string },\n  ): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.inboundApplication.patch, { ...options })),\n  deleteApplication: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.inboundApplication.delete, { id })),\n  loadApplication: (id: string): Promise<SdkResponse<InboundApplication>> =>\n    transformResponse<InboundApplication, InboundApplication>(\n      httpClient.get(apiPaths.inboundApplication.load, {\n        queryParams: { id },\n      }),\n      (data) => data,\n    ),\n  loadAllApplications: (): Promise<SdkResponse<InboundApplication[]>> =>\n    transformResponse<MultipleInboundApplicationResponse, InboundApplication[]>(\n      httpClient.get(apiPaths.inboundApplication.loadAll, {}),\n      (data) => data.apps,\n    ),\n  getApplicationSecret: (id: string): Promise<SdkResponse<InboundApplicationSecretResponse>> =>\n    transformResponse<InboundApplicationSecretResponse, InboundApplicationSecretResponse>(\n      httpClient.get(apiPaths.inboundApplication.secret, {\n        queryParams: { id },\n      }),\n      (data) => data,\n    ),\n  rotateApplicationSecret: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.inboundApplication.rotate, { id })),\n  searchConsents: (\n    options?: InboundApplicationConsentSearchOptions,\n  ): Promise<SdkResponse<InboundApplicationConsent[]>> =>\n    transformResponse<MultipleInboundApplicationConsentsResponse, InboundApplicationConsent[]>(\n      httpClient.post(apiPaths.inboundApplicationConsents.search, { ...options }),\n      (data) => data.consents,\n    ),\n  deleteConsents: (options: InboundApplicationConsentDeleteOptions): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.inboundApplicationConsents.delete, { ...options })),\n});\n\nexport default withInboundApplication;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport {\n  OutboundApplication,\n  OutboundAppToken,\n  FetchOutboundAppTokenOptions,\n  OutboundAppTokenResponse,\n} from './types';\n\ntype OutboundApplicationResponse = {\n  app: OutboundApplication;\n};\n\ntype MultipleOutboundApplicationResponse = {\n  apps: OutboundApplication[];\n};\n\ntype WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n\nconst withOutboundApplication = (httpClient: HttpClient) => ({\n  createApplication: (\n    app: WithOptional<OutboundApplication, 'id'> & { clientSecret?: string },\n  ): Promise<SdkResponse<OutboundApplication>> =>\n    transformResponse<OutboundApplicationResponse, OutboundApplication>(\n      httpClient.post(apiPaths.outboundApplication.create, {\n        ...app,\n      }),\n      (data) => data.app,\n    ),\n  updateApplication: (\n    app: OutboundApplication & { clientSecret?: string },\n  ): Promise<SdkResponse<OutboundApplication>> =>\n    transformResponse<OutboundApplicationResponse, OutboundApplication>(\n      httpClient.post(apiPaths.outboundApplication.update, {\n        app,\n      }),\n      (data) => data.app,\n    ),\n  deleteApplication: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.outboundApplication.delete, { id })),\n  loadApplication: (id: string): Promise<SdkResponse<OutboundApplication>> =>\n    transformResponse<OutboundApplicationResponse, OutboundApplication>(\n      httpClient.get(`${apiPaths.outboundApplication.load}/${id}`),\n      (data) => data.app,\n    ),\n  loadAllApplications: (): Promise<SdkResponse<OutboundApplication[]>> =>\n    transformResponse<MultipleOutboundApplicationResponse, OutboundApplication[]>(\n      httpClient.get(apiPaths.outboundApplication.loadAll, {}),\n      (data) => data.apps,\n    ),\n  fetchTokenByScopes: (\n    appId: string,\n    userId: string,\n    scopes: string[],\n    options?: FetchOutboundAppTokenOptions,\n    tenantId?: string,\n  ): Promise<SdkResponse<OutboundAppToken>> =>\n    transformResponse<OutboundAppTokenResponse, OutboundAppToken>(\n      httpClient.post(apiPaths.outboundApplication.fetchTokenByScopes, {\n        appId,\n        userId,\n        scopes,\n        options,\n        tenantId,\n      }),\n      (data) => data.token,\n    ),\n  fetchToken: (\n    appId: string,\n    userId: string,\n    tenantId?: string,\n    options?: FetchOutboundAppTokenOptions,\n  ): Promise<SdkResponse<OutboundAppToken>> =>\n    transformResponse<OutboundAppTokenResponse, OutboundAppToken>(\n      httpClient.post(apiPaths.outboundApplication.fetchToken, {\n        appId,\n        userId,\n        tenantId,\n        options,\n      }),\n      (data) => data.token,\n    ),\n  fetchTenantTokenByScopes: (\n    appId: string,\n    tenantId: string,\n    scopes: string[],\n    options?: FetchOutboundAppTokenOptions,\n  ): Promise<SdkResponse<OutboundAppToken>> =>\n    transformResponse<OutboundAppTokenResponse, OutboundAppToken>(\n      httpClient.post(apiPaths.outboundApplication.fetchTenantTokenByScopes, {\n        appId,\n        tenantId,\n        scopes,\n        options,\n      }),\n      (data) => data.token,\n    ),\n  fetchTenantToken: (\n    appId: string,\n    tenantId: string,\n    options?: FetchOutboundAppTokenOptions,\n  ): Promise<SdkResponse<OutboundAppToken>> =>\n    transformResponse<OutboundAppTokenResponse, OutboundAppToken>(\n      httpClient.post(apiPaths.outboundApplication.fetchTenantToken, {\n        appId,\n        tenantId,\n        options,\n      }),\n      (data) => data.token,\n    ),\n  deleteUserTokens: (appId?: string, userId?: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.delete(apiPaths.outboundApplication.deleteUserTokens, {\n        queryParams: { appId, userId },\n      }),\n    ),\n  deleteTokenById: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.delete(apiPaths.outboundApplication.deleteTokenById, {\n        queryParams: { id },\n      }),\n    ),\n});\n\nexport default withOutboundApplication;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport { Descoper, DescoperAttributes, DescoperCreate, DescoperRBAC } from './types';\n\ntype DescoperCreateResponse = {\n  descopers: Descoper[];\n  total: number;\n};\n\ntype DescoperGetResponse = {\n  descoper: Descoper;\n};\n\ntype DescoperUpdateResponse = {\n  descoper: Descoper;\n};\n\ntype DescoperListResponse = {\n  descopers: Descoper[];\n  total: number;\n};\n\nconst withDescoper = (httpClient: HttpClient) => ({\n  /**\n   * Create new descoper(s)\n   * @param descopers Array of descoper creation objects\n   * @returns The newly created descopers and total count\n   */\n  create: (descopers: DescoperCreate[]): Promise<SdkResponse<DescoperCreateResponse>> =>\n    transformResponse(httpClient.put(apiPaths.descoper.create, { descopers }), (data) => ({\n      descopers: data.descopers,\n      total: data.total,\n    })),\n\n  /**\n   * Update an existing descoper's attributes and/or RBAC\n   * @param id The descoper ID\n   * @param attributes Optional attributes to update\n   * @param rbac Optional RBAC configuration to update\n   * @returns The updated descoper\n   */\n  update: (\n    id: string,\n    attributes?: DescoperAttributes,\n    rbac?: DescoperRBAC,\n  ): Promise<SdkResponse<Descoper>> =>\n    transformResponse<DescoperUpdateResponse, Descoper>(\n      httpClient.patch(apiPaths.descoper.update, { id, attributes, rbac }),\n      (data) => data.descoper,\n    ),\n\n  /**\n   * Load a descoper by ID\n   * @param id The descoper ID\n   * @returns The descoper\n   */\n  load: (id: string): Promise<SdkResponse<Descoper>> =>\n    transformResponse<DescoperGetResponse, Descoper>(\n      httpClient.get(apiPaths.descoper.get, { queryParams: { id } }),\n      (data) => data.descoper,\n    ),\n\n  /**\n   * Delete a descoper by ID\n   * @param id The descoper ID\n   */\n  delete: (id: string): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.delete(apiPaths.descoper.delete, { queryParams: { id } })),\n\n  /**\n   * List all descopers\n   * @returns List of descopers and total count\n   */\n  list: (): Promise<SdkResponse<DescoperListResponse>> =>\n    transformResponse(httpClient.post(apiPaths.descoper.list), (data) => ({\n      descopers: data.descopers,\n      total: data.total,\n    })),\n});\n\nexport default withDescoper;\n","import { HttpClient, SdkResponse, transformResponse } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport { MgmtKey, MgmtKeyCreateResponse, MgmtKeyReBac, MgmtKeyStatus } from './types';\n\nconst withManagementKey = (httpClient: HttpClient) => ({\n  create: (\n    name: string,\n    reBac: MgmtKeyReBac,\n    description?: string,\n    expiresIn?: number,\n    permittedIps?: string[],\n  ): Promise<SdkResponse<MgmtKeyCreateResponse>> =>\n    transformResponse(\n      httpClient.put(apiPaths.managementKey.create, {\n        name,\n        description,\n        expiresIn,\n        permittedIps,\n        reBac,\n      }),\n    ),\n\n  update: (\n    id: string,\n    name: string,\n    description: string,\n    status: MgmtKeyStatus,\n    permittedIps?: string[],\n  ): Promise<SdkResponse<MgmtKey>> =>\n    transformResponse(\n      httpClient.patch(apiPaths.managementKey.update, {\n        id,\n        name,\n        description,\n        permittedIps,\n        status,\n      }),\n      (data) => data.key,\n    ),\n\n  delete: (ids: string[]): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.managementKey.delete, { ids })),\n\n  load: (id: string): Promise<SdkResponse<MgmtKey>> =>\n    transformResponse(\n      httpClient.get(apiPaths.managementKey.load, { queryParams: { id } }),\n      (data) => data.key,\n    ),\n\n  search: (): Promise<SdkResponse<MgmtKey[]>> =>\n    transformResponse(httpClient.get(apiPaths.managementKey.search), (data) => data.keys),\n});\n\nexport default withManagementKey;\n","import createSdk, {\n  AccessKeyLoginOptions,\n  ExchangeAccessKeyResponse,\n  SdkResponse,\n  JWTResponse as CoreJWTResponse,\n  wrapWith,\n  createHttpClient,\n  RequestConfig,\n} from '@descope/core-js-sdk';\nimport { JWK, JWTHeaderParameters, KeyLike, errors, importJWK, jwtVerify } from 'jose';\nimport {\n  permissionsClaimName,\n  refreshTokenCookieName,\n  rolesClaimName,\n  sessionTokenCookieName,\n} from './constants';\nimport fetch from './fetch-polyfill';\nimport {\n  getAuthorizationClaimItems,\n  getCookieValue,\n  isUserAssociatedWithTenant,\n  withCookie,\n} from './helpers';\nimport withManagement from './management';\nimport { AuthenticationInfo, RefreshAuthenticationInfo, VerifyOptions } from './types';\nimport descopeErrors from './errors';\n\ndeclare const BUILD_VERSION: string;\n\n// Extend the type wrapped by withCookie\ntype JWTResponseWithCookies = CoreJWTResponse & {\n  cookies: string[];\n};\n\n/** Configuration arguments which include the Descope core SDK args and an optional management key */\ntype NodeSdkArgs = Parameters<typeof createSdk>[0] & {\n  managementKey?: string;\n  authManagementKey?: string;\n  publicKey?: string;\n  fgaCacheUrl?: string;\n};\n\nconst nodeSdk = ({\n  authManagementKey,\n  managementKey,\n  publicKey,\n  fgaCacheUrl,\n  ...config\n}: NodeSdkArgs) => {\n  const nodeHeaders = {\n    'x-descope-sdk-name': 'nodejs',\n    'x-descope-sdk-node-version': process?.versions?.node || '',\n    'x-descope-sdk-version': BUILD_VERSION,\n  };\n\n  const authSdkConfig = {\n    fetch,\n    ...config,\n    baseHeaders: {\n      ...config.baseHeaders,\n      ...nodeHeaders,\n    },\n    hooks: {\n      ...config.hooks,\n      beforeRequest: [\n        // auth requests append the auth management key if provided\n        (requestConfig: RequestConfig) => {\n          if (authManagementKey) {\n            // eslint-disable-next-line no-param-reassign\n            requestConfig.token = !requestConfig.token\n              ? authManagementKey\n              : `${requestConfig.token}:${authManagementKey}`;\n          }\n\n          return requestConfig;\n        },\n      ].concat(config.hooks?.beforeRequest || []),\n    },\n  };\n  const coreSdk = createSdk(authSdkConfig);\n\n  const { projectId, logger } = config;\n\n  const keys: Record<string, KeyLike | Uint8Array> = {};\n\n  /** Fetch the public keys (JWKs) from Descope for the configured project */\n  const fetchKeys = async () => {\n    if (publicKey) {\n      try {\n        const parsedKey = JSON.parse(publicKey);\n        const key = await importJWK(parsedKey);\n        return {\n          [parsedKey.kid]: key,\n        };\n      } catch (e) {\n        logger?.error('Failed to parse the provided public key', e);\n        throw new Error(`Failed to parse public key. Error: ${e}`);\n      }\n    }\n\n    const keysWrapper = await coreSdk.httpClient\n      .get(`v2/keys/${projectId}`)\n      .then((resp) => resp.json());\n    const publicKeys: JWK[] = keysWrapper.keys;\n    if (!Array.isArray(publicKeys)) return {};\n    const kidJwksPairs = await Promise.all(\n      publicKeys.map(async (key) => [key.kid, await importJWK(key)]),\n    );\n\n    return kidJwksPairs.reduce(\n      (acc, [kid, jwk]) => (kid ? { ...acc, [kid.toString()]: jwk } : acc),\n      {},\n    );\n  };\n\n  const mgmtSdkConfig = {\n    fetch,\n    ...config,\n    baseConfig: {\n      baseHeaders: {\n        ...config.baseHeaders,\n        ...nodeHeaders,\n      },\n    },\n    hooks: {\n      ...config.hooks,\n      beforeRequest: [\n        // management requests always use the management key as the token\n        (requestConfig: RequestConfig) => {\n          // eslint-disable-next-line no-param-reassign\n          requestConfig.token = managementKey;\n          return requestConfig;\n        },\n      ].concat(config.hooks?.beforeRequest || []),\n    },\n  };\n  const mgmtHttpClient = createHttpClient(mgmtSdkConfig);\n  const management = withManagement(mgmtHttpClient, {\n    fgaCacheUrl,\n    managementKey,\n    projectId,\n    headers: nodeHeaders,\n  });\n\n  const sdk = {\n    ...coreSdk,\n\n    // Overrides core-sdk refresh, because the core-sdk exposes queryParams, which is for internal use only\n    refresh: async (token?: string, externalToken?: string) =>\n      coreSdk.refresh(token, undefined, externalToken),\n\n    /**\n     * Provides various APIs for managing a Descope project programmatically. A management key must\n     * be provided as an argument when initializing the SDK to use these APIs. Management keys can be\n     * generated in the Descope console.\n     */\n    management,\n\n    /** Get the key that can validate the given JWT KID in the header. Can retrieve the public key from local cache or from Descope. */\n    async getKey(header: JWTHeaderParameters): Promise<KeyLike | Uint8Array> {\n      if (!header?.kid) throw Error('header.kid must not be empty');\n\n      if (keys[header.kid]) return keys[header.kid];\n\n      // do we need to fetch once or every time?\n      Object.assign(keys, await fetchKeys());\n\n      if (!keys[header.kid]) throw Error('failed to fetch matching key');\n\n      return keys[header.kid];\n    },\n\n    /**\n     * Validate the given JWT with the right key and make sure the issuer is correct\n     * @param jwt the JWT string to parse and validate\n     * @param options optional verification options (e.g., { audience })\n     * @returns AuthenticationInfo with the parsed token and JWT. Will throw an error if validation fails.\n     */\n    async validateJwt(jwt: string, options?: VerifyOptions): Promise<AuthenticationInfo> {\n      // Do not hard-code the algo because library does not support `None` so all are valid\n      const verifyOptions: Record<string, unknown> = { clockTolerance: 5 };\n      if (options?.audience) verifyOptions.audience = options.audience;\n      const res = await jwtVerify(jwt, sdk.getKey, verifyOptions);\n      const token = res.payload;\n\n      if (token) {\n        token.iss = token.iss?.split('/').pop(); // support both url and project id as issuer\n        if (token.iss !== projectId) {\n          // We must do the verification here, since issuer can be either project ID or URL\n          throw new errors.JWTClaimValidationFailed(\n            'unexpected \"iss\" claim value',\n            'iss',\n            'check_failed',\n          );\n        }\n      }\n\n      return { jwt, token };\n    },\n\n    /**\n     * Validate an active session\n     * @param sessionToken session JWT to validate\n     * @param options optional verification options (e.g., { audience })\n     * @returns AuthenticationInfo promise or throws Error if there is an issue with JWTs\n     */\n    async validateSession(\n      sessionToken: string,\n      options?: VerifyOptions,\n    ): Promise<AuthenticationInfo> {\n      if (!sessionToken) throw Error('session token is required for validation');\n\n      try {\n        const token = await sdk.validateJwt(sessionToken, options);\n        return token;\n      } catch (error) {\n        /* istanbul ignore next */\n        logger?.error('session validation failed', error);\n        throw Error(`session validation failed. Error: ${error}`);\n      }\n    },\n\n    /**\n     * Refresh the session using a refresh token.\n     * For session migration, use {@link sdk.refresh}.\n     *\n     * @param refreshToken refresh JWT to refresh the session with\n     * @param options optional verification options for the new session (e.g., { audience })\n     * @returns RefreshAuthenticationInfo promise or throws Error if there is an issue with JWTs\n     */\n    async refreshSession(\n      refreshToken: string,\n      options?: VerifyOptions,\n    ): Promise<RefreshAuthenticationInfo> {\n      if (!refreshToken) throw Error('refresh token is required to refresh a session');\n\n      try {\n        await sdk.validateJwt(refreshToken);\n        const jwtResp = await sdk.refresh(refreshToken);\n        if (jwtResp.ok) {\n          // if refresh was successful, validate the new session JWT\n          const sessionJwt =\n            getCookieValue(\n              (jwtResp.data as JWTResponseWithCookies)?.cookies?.join(';'),\n              sessionTokenCookieName,\n            ) || jwtResp.data?.sessionJwt;\n          const token = await sdk.validateJwt(sessionJwt, options);\n          // add cookies to the token response if they exist\n          token.cookies = (jwtResp.data as JWTResponseWithCookies)?.cookies || [];\n          if (jwtResp.data?.refreshJwt) {\n            // if refresh returned a refresh JWT, add it to the response\n            (token as RefreshAuthenticationInfo).refreshJwt = jwtResp.data.refreshJwt;\n          }\n          return token;\n        }\n        /* istanbul ignore next */\n        throw Error(jwtResp.error?.errorMessage);\n      } catch (refreshTokenErr) {\n        /* istanbul ignore next */\n        logger?.error('refresh token validation failed', refreshTokenErr);\n        throw Error(`refresh token validation failed, Error: ${refreshTokenErr}`);\n      }\n    },\n\n    /**\n     * Validate session and refresh it if it expired\n     * @param sessionToken session JWT\n     * @param refreshToken refresh JWT\n     * @param options optional verification options (e.g., { audience }) used on validation and post-refresh\n     * @returns RefreshAuthenticationInfo promise or throws Error if there is an issue with JWTs\n     */\n    async validateAndRefreshSession(\n      sessionToken?: string,\n      refreshToken?: string,\n      options?: VerifyOptions,\n    ): Promise<RefreshAuthenticationInfo> {\n      if (!sessionToken && !refreshToken) throw Error('both session and refresh tokens are empty');\n\n      try {\n        const token = await sdk.validateSession(sessionToken, options);\n        return token;\n      } catch (error) {\n        /* istanbul ignore next */\n        logger?.log(`session validation failed with error ${error} - trying to refresh it`);\n      }\n\n      return sdk.refreshSession(refreshToken, options);\n    },\n\n    /**\n     * Exchange API key (access key) for a session key\n     * @param accessKey access key to exchange for a session JWT\n     * @param loginOptions Optional advanced controls over login parameters\n     * @param options optional verification options for the returned session (e.g., { audience })\n     * @returns AuthenticationInfo with session JWT data\n     */\n    async exchangeAccessKey(\n      accessKey: string,\n      loginOptions?: AccessKeyLoginOptions,\n      options?: VerifyOptions,\n    ): Promise<AuthenticationInfo> {\n      if (!accessKey) throw Error('access key must not be empty');\n\n      let resp: SdkResponse<ExchangeAccessKeyResponse>;\n      try {\n        resp = await sdk.accessKey.exchange(accessKey, loginOptions);\n      } catch (error) {\n        logger?.error('failed to exchange access key', error);\n        throw Error(`could not exchange access key - Failed to exchange. Error: ${error}`);\n      }\n\n      if (!resp.ok) {\n        logger?.error('failed to exchange access key', resp.error);\n        throw Error(`could not exchange access key - ${resp.error?.errorMessage}`);\n      }\n\n      const { sessionJwt } = resp.data;\n      if (!sessionJwt) {\n        logger?.error('failed to parse exchange access key response');\n        throw Error('could not exchange access key');\n      }\n\n      try {\n        const token = await sdk.validateJwt(sessionJwt, options);\n        return token;\n      } catch (error) {\n        logger?.error('failed to parse jwt from access key', error);\n        throw Error(`could not exchange access key - failed to validate jwt. Error: ${error}`);\n      }\n    },\n\n    /**\n     * Make sure that all given permissions exist on the parsed JWT top level claims\n     * @param authInfo JWT parsed info\n     * @param permissions list of permissions to make sure they exist on te JWT claims\n     * @returns true if all permissions exist, false otherwise\n     */\n    validatePermissions(authInfo: AuthenticationInfo, permissions: string[]): boolean {\n      return sdk.validateTenantPermissions(authInfo, '', permissions);\n    },\n\n    /**\n     * Retrieves the permissions from JWT top level claims that match the specified permissions list\n     * @param authInfo JWT parsed info containing the permissions\n     * @param permissions List of permissions to match against the JWT claims\n     * @returns An array of permissions that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     */\n    getMatchedPermissions(authInfo: AuthenticationInfo, permissions: string[]): string[] {\n      return sdk.getMatchedTenantPermissions(authInfo, '', permissions);\n    },\n\n    /**\n     * Make sure that all given permissions exist on the parsed JWT tenant claims\n     * @param authInfo JWT parsed info\n     * @param tenant tenant to validate the permissions for\n     * @param permissions list of permissions to make sure they exist on te JWT claims\n     * @returns true if all permissions exist, false otherwise\n     */\n    validateTenantPermissions(\n      authInfo: AuthenticationInfo,\n      tenant: string,\n      permissions: string[],\n    ): boolean {\n      // check if user is associated to the tenant\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return false;\n\n      const granted = getAuthorizationClaimItems(authInfo, permissionsClaimName, tenant);\n      return permissions.every((perm) => granted.includes(perm));\n    },\n\n    /**\n     * Retrieves the permissions from JWT tenant claims that match the specified permissions list\n     * @param authInfo JWT parsed info containing the permissions\n     * @param tenant tenant to match the permissions for\n     * @param permissions List of permissions to match against the JWT claims\n     * @returns An array of permissions that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     * */\n    getMatchedTenantPermissions(\n      authInfo: AuthenticationInfo,\n      tenant: string,\n      permissions: string[],\n    ): string[] {\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return [];\n\n      const granted = getAuthorizationClaimItems(authInfo, permissionsClaimName, tenant);\n      return permissions.filter((perm) => granted.includes(perm));\n    },\n\n    /**\n     * Make sure that all given roles exist on the parsed JWT top level claims\n     * @param authInfo JWT parsed info\n     * @param roles list of roles to make sure they exist on te JWT claims\n     * @returns true if all roles exist, false otherwise\n     */\n    validateRoles(authInfo: AuthenticationInfo, roles: string[]): boolean {\n      return sdk.validateTenantRoles(authInfo, '', roles);\n    },\n\n    /**\n     * Retrieves the roles from JWT top level claims that match the specified roles list\n     * @param authInfo JWT parsed info containing the roles\n     * @param roles List of roles to match against the JWT claims\n     * @returns An array of roles that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     */\n    getMatchedRoles(authInfo: AuthenticationInfo, roles: string[]): string[] {\n      return sdk.getMatchedTenantRoles(authInfo, '', roles);\n    },\n\n    /**\n     * Make sure that all given roles exist on the parsed JWT tenant claims\n     * @param authInfo JWT parsed info\n     * @param tenant tenant to validate the roles for\n     * @param roles list of roles to make sure they exist on te JWT claims\n     * @returns true if all roles exist, false otherwise\n     */\n    validateTenantRoles(authInfo: AuthenticationInfo, tenant: string, roles: string[]): boolean {\n      // check if user is associated to the tenant\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return false;\n\n      const membership = getAuthorizationClaimItems(authInfo, rolesClaimName, tenant);\n      return roles.every((role) => membership.includes(role));\n    },\n\n    /**\n     * Retrieves the roles from JWT tenant claims that match the specified roles list\n     * @param authInfo JWT parsed info containing the roles\n     * @param tenant tenant to match the roles for\n     * @param roles List of roles to match against the JWT claims\n     * @returns An array of roles that are both in the JWT claims and the specified list. Returns an empty array if no matches are found\n     */\n    getMatchedTenantRoles(authInfo: AuthenticationInfo, tenant: string, roles: string[]): string[] {\n      if (tenant && !isUserAssociatedWithTenant(authInfo, tenant)) return [];\n\n      const membership = getAuthorizationClaimItems(authInfo, rolesClaimName, tenant);\n      return roles.filter((role) => membership.includes(role));\n    },\n  };\n\n  return wrapWith(\n    sdk,\n    [\n      'otp.verify.email',\n      'otp.verify.sms',\n      'otp.verify.voice',\n      'otp.verify.whatsapp',\n      'otp.verify.im',\n      'magicLink.verify',\n      'enchantedLink.signUp',\n      'enchantedLink.signIn',\n      'oauth.exchange',\n      'saml.exchange',\n      'totp.verify',\n      'webauthn.signIn.finish',\n      'webauthn.signUp.finish',\n      'refresh',\n    ] as const,\n    withCookie,\n  );\n};\n\n/** Descope SDK client with delivery methods enum.\n *\n * Please see full documentation at {@link https://docs.descope.com/guides Descope Docs}\n * @example Usage\n *\n * ```js\n * import descopeSdk from '@descope/node-sdk';\n *\n * const myProjectId = 'xxx';\n * const sdk = descopeSdk({ projectId: myProjectId });\n *\n * const userLoginId = 'loginId';\n * sdk.otp.signIn.email(userLoginId);\n * const jwtResponse = sdk.otp.verify.email(userLoginId, codeFromEmail);\n * ```\n */\n\nnodeSdk.RefreshTokenCookieName = refreshTokenCookieName;\nnodeSdk.SessionTokenCookieName = sessionTokenCookieName;\nnodeSdk.DescopeErrors = descopeErrors;\n\nexport default nodeSdk;\nexport type {\n  DeliveryMethod,\n  JWTResponse,\n  OAuthProvider,\n  ResponseData,\n  SdkResponse,\n} from '@descope/core-js-sdk';\nexport type { AuthenticationInfo, RefreshAuthenticationInfo };\nexport type { VerifyOptions } from './types';\nexport * from './management/types';\nexport type { PatchUserOptions } from './management/user';\n","import { HttpClient } from '@descope/core-js-sdk';\nimport withUser from './user';\nimport withProject from './project';\nimport withTenant from './tenant';\nimport withJWT from './jwt';\nimport withPermission from './permission';\nimport withRole from './role';\nimport withGroup from './group';\nimport withSSOSettings from './sso';\nimport withAccessKey from './accesskey';\nimport WithFlow from './flow';\nimport WithTheme from './theme';\nimport WithAudit from './audit';\nimport WithAuthz from './authz';\nimport withSSOApplication from './ssoapplication';\nimport withPassword from './password';\nimport WithFGA from './fga';\nimport withInboundApplication from './inboundapplication';\nimport withOutboundApplication from './outboundapplication';\nimport withDescoper from './descoper';\nimport withManagementKey from './managementKey';\nimport { FGAConfig } from './types';\n\n/** Constructs a higher level Management API that wraps the functions from code-js-sdk */\nconst withManagement = (client: HttpClient, fgaConfig?: FGAConfig) => ({\n  user: withUser(client),\n  project: withProject(client),\n  accessKey: withAccessKey(client),\n  tenant: withTenant(client),\n  ssoApplication: withSSOApplication(client),\n  inboundApplication: withInboundApplication(client),\n  outboundApplication: withOutboundApplication(client),\n  sso: withSSOSettings(client),\n  jwt: withJWT(client),\n  permission: withPermission(client),\n  password: withPassword(client),\n  role: withRole(client),\n  group: withGroup(client),\n  flow: WithFlow(client),\n  theme: WithTheme(client),\n  audit: WithAudit(client),\n  authz: WithAuthz(client),\n  fga: WithFGA(client, fgaConfig),\n  descoper: withDescoper(client),\n  managementKey: withManagementKey(client),\n});\n\nexport default withManagement;\n","import { SdkResponse, transformResponse, HttpClient } from '@descope/core-js-sdk';\nimport apiPaths from './paths';\nimport {\n  CloneProjectResponse,\n  ExportSnapshotResponse,\n  ImportSnapshotRequest,\n  Project,\n  ProjectEnvironment,\n  ValidateSnapshotRequest,\n  ValidateSnapshotResponse,\n} from './types';\n\ntype ListProjectsResponse = {\n  projects: Project[];\n};\n\nconst withProject = (httpClient: HttpClient) => ({\n  /**\n   * Update the current project name.\n   * @param name The new name of the project\n   */\n  updateName: (name: string): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.project.updateName, {\n        name,\n      }),\n    ),\n\n  /**\n   * Update the current project tags.\n   * @param tags The wanted tags\n   */\n  updateTags: (tags: string[]): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.project.updateTags, {\n        tags,\n      }),\n    ),\n  /**\n   * Clone the current project, including its settings and configurations.\n   *  - This action is supported only with a pro license or above.\n   *  - Users, tenants and access keys are not cloned.\n   * @param name The name of the new project\n   * @param environment Determine if the project is in production or not.\n   * @param tags array of free text tags\n   * @returns The new project details (name, id, environment and tags)\n   */\n  clone: (\n    name: string,\n    environment?: ProjectEnvironment,\n    tags?: string[],\n  ): Promise<SdkResponse<CloneProjectResponse>> =>\n    transformResponse(\n      httpClient.post(apiPaths.project.clone, {\n        name,\n        environment,\n        tags,\n      }),\n    ),\n\n  /**\n   * list of all the projects in the company\n   * @returns List of projects details (name, id, environment and tags)\n   */\n  listProjects: async (): Promise<SdkResponse<Project[]>> =>\n    transformResponse<ListProjectsResponse, Project[]>(\n      httpClient.post(apiPaths.project.projectsList, {}),\n      (data) =>\n        data.projects.map(({ id, name, environment, tags }) => ({\n          id,\n          name,\n          environment,\n          tags,\n        })),\n    ),\n\n  /**\n   *\n   * Exports a snapshot of all the settings and configurations for a project and returns\n   * the raw JSON files as a mape. Note that users, tenants and access keys are not exported.\n   *\n   * This call is supported only with a pro license or above.\n   *\n   * Note: The values for secrets such as tokens and keys are left blank in the snapshot.\n   * When a snapshot is imported into a project, the secrets for entities that already\n   * exist such as connectors or OAuth providers are preserved if the matching values\n   * in the snapshot are left blank. See below for more details.\n   *\n   * This API is meant to be used via the 'descope' CLI tool that can be\n   * found at https://github.com/descope/descopecli\n   *\n   * @returns An `ExportSnapshotResponse` object containing the exported JSON files.\n   */\n  exportSnapshot: (): Promise<SdkResponse<ExportSnapshotResponse>> =>\n    transformResponse(httpClient.post(apiPaths.project.exportSnapshot, {})),\n\n  /**\n   * Imports a snapshot of all settings and configurations into a project, overriding any\n   * current configuration.\n   *\n   * This call is supported only with a pro license or above.\n   *\n   * The request is expected to be an `ImportSnapshotRequest` object with a raw JSON map of\n   * files in the same format as the one returned in the `files` field of an `exportSnapshot`\n   * response.\n   *\n   * Note: The values for secrets such as tokens and keys are left blank in exported\n   * snapshots. When a snapshot is imported into a project, the secrets for entities that\n   * already exist such as connectors or OAuth providers are preserved if the matching values\n   * in the snapshot are left blank. However, new entities that need to be created during\n   * the import operation must any required secrets provided in the request, otherwise the\n   * import operation will fail. The ValidateImport method can be used to get a human and\n   * machine readable JSON of missing secrets that be passed to the ImportSnapshot call.\n   *\n   * This API is meant to be used via the 'descope' CLI tool that can be\n   * found at https://github.com/descope/descopecli\n   */\n  importSnapshot: (request: ImportSnapshotRequest): Promise<SdkResponse<never>> =>\n    transformResponse(httpClient.post(apiPaths.project.importSnapshot, request)),\n\n  /**\n   * Validates a snapshot by performing an import dry run and reporting any validation\n   * failures or missing data. This should be called right before `importSnapshot` to\n   * minimize the risk of the import failing.\n   *\n   * This call is supported only with a pro license or above.\n   *\n   * The response will have `ok: true` if the validation passes. Otherwise, a list of\n   * failures will be provided in the `failures` field, and any missing secrets will\n   * be listed along with details about which entity requires them.\n   *\n   * Validation can be retried by setting the required cleartext secret values in the\n   * `value` field of each missing secret and setting this object as the `inputSecrets`\n   * field of the validate request. The same `inputSecrets` object should then be\n   * provided to the `importSnapshot` call afterwards so it doesn't fail as well.\n   *\n   * This API is meant to be used via the 'descope' CLI tool that can be\n   * found at https://github.com/descope/descopecli\n   */\n  validateSnapshot: (\n    request: ValidateSnapshotRequest,\n  ): Promise<SdkResponse<ValidateSnapshotResponse>> =>\n    transformResponse(httpClient.post(apiPaths.project.validateSnapshot, request)),\n\n  /**\n   * @deprecated Use exportSnapshot instead\n   */\n  export: (): Promise<SdkResponse<Record<string, any>>> =>\n    transformResponse(httpClient.post(apiPaths.project.exportSnapshot, {}), (data) => data.files),\n\n  /**\n   * @deprecated Use importSnapshot instead\n   */\n  import: (files: Record<string, any>): Promise<SdkResponse<never>> =>\n    transformResponse(\n      httpClient.post(apiPaths.project.importSnapshot, {\n        files,\n      }),\n    ),\n});\n\nexport default withProject;\n","/** Common Error Codes */\nexport default {\n  badRequest: 'E011001',\n  missingArguments: 'E011002',\n  invalidRequest: 'E011003',\n  invalidArguments: 'E011004',\n  wrongOTPCode: 'E061102',\n  tooManyOTPAttempts: 'E061103',\n  enchantedLinkPending: 'E062503',\n  userNotFound: 'E062108',\n};\n"],"names":["_a","globalThis","Headers","patchedFetch","args","forEach","arg","_b","highWaterMark","crossFetch","fetch","getCookieValue","cookie","name","match","RegExp","withCookie","fn","async","resp","data","_d","refreshJwt","rest","__rest","cookies","options","push","cookieDomain","cookieMaxAge","cookiePath","response","headers","get","_c","Object","assign","getAuthorizationClaimItems","authInfo","claim","tenant","value","token","Array","isArray","isUserAssociatedWithTenant","apiPaths","create","createTestUser","createBatch","update","patch","patchBatch","delete","deleteBatch","deleteAllTestUsers","load","logout","loadUsers","search","searchTestUsers","getProviderToken","updateStatus","updateLoginId","updateEmail","updatePhone","updateDisplayName","updatePicture","updateCustomAttribute","setRole","addRole","removeRole","setSSOApps","addSSOApps","removeSSOApps","addTenant","removeTenant","setPassword","setTemporaryPassword","setActivePassword","expirePassword","removeAllPasskeys","removeTOTPSeed","generateOTPForTest","generateMagicLinkForTest","generateEnchantedLinkForTest","generateEmbeddedLink","generateSignUpEmbeddedLink","history","updateName","updateTags","clone","projectsList","exportSnapshot","importSnapshot","validateSnapshot","deactivate","activate","settings","loadAll","searchAll","generateSSOConfigurationLink","oidcCreate","samlCreate","oidcUpdate","samlUpdate","secret","rotate","fetchToken","fetchTokenByScopes","fetchTenantToken","fetchTenantTokenByScopes","deleteUserTokens","deleteTokenById","settingsNew","metadata","mapping","settingsv2","settingsAllV2","oidc","configure","saml","impersonate","stopImpersonation","signIn","signUp","signUpOrIn","anonymous","clientAssertion","list","export","import","run","loadAllGroups","loadAllGroupsForMember","loadAllGroupMembers","createEvent","schemaSave","schemaDelete","schemaLoad","nsSave","nsDelete","rdSave","rdDelete","reCreate","reDelete","reDeleteResources","reDeleteResourceRelationsForResources","hasRelations","who","resource","targets","targetAll","targetWithRelation","getModified","schema","relations","deleteRelations","check","resourcesLoad","resourcesSave","transformUsersForBatch","users","map","roles","user","roleNames","withUser","httpClient","buildPatchRequestBody","loginId","body","undefined","email","phone","displayName","givenName","middleName","familyName","userTenants","customAttributes","picture","verifiedEmail","verifiedPhone","ssoAppIds","scim","status","emailOrOptions","additionalLoginIds","transformResponse","post","test","invite","inviteUrl","sendMail","sendSMS","templateId","inviteBatch","templateOptions","userIds","deleteByUserId","userId","queryParams","loadByUserId","logoutUser","logoutUserByUserId","includeInvalidUsers","tenantIds","limit","page","testUsersOnly","withTestUser","statuses","emails","phones","searchReq","provider","providerTokenOptions","withRefreshToken","forceRefresh","newLoginId","isVerified","failOnConflict","verified","attributeKey","attributeValue","setRoles","addRoles","removeRoles","tenantId","setTenantRoles","addTenantRoles","removeTenantRoles","addSSOapps","setSSOapps","removeSSOapps","generateOTPForTestUser","deliveryMethod","loginOptions","generateMagicLinkForTestUser","uri","URI","generateEnchantedLinkForTestUser","customClaims","timeout","emailVerified","phoneVerified","password","withTenant","selfProvisioningDomains","enforceSSO","disabled","parent","createWithId","id","cascade","tenants","ids","names","parentTenantId","tenantNames","tenantSelfProvisioningDomains","getSettings","configureSettings","expireDuration","ssoId","expireTime","withJWT","jwt","refreshDuration","impersonatorId","validateConsent","selectedTenant","signUpOptions","generateClientAssertionJwt","issuer","subject","audience","expiresIn","flattenAudience","algorithm","withPermission","description","newName","permissions","withRole","permissionNames","defaultRole","default","withGroup","loginIds","groupId","transformSettingsResponse","readySettings","attributeMapping","userAttrMapping","groupsMapping","gm","rm","roleName","role","withSSOSettings","newSettings","deleteSettings","idpURL","idpCert","entityId","redirectURL","domains","configureMetadata","idpMetadataURL","configureMapping","roleMappings","configureOIDCSettings","configureSAMLSettings","redirectUrl","configureSAMLByMetadata","loadSettings","loadAllSettings","SSOSettings","res","setting","transformAllSettingsResponse","withAccessKey","permittedIps","keyTenants","key","keys","WithFlow","flowIds","flowId","flow","screens","output","WithTheme","theme","WithAudit","searchOptions","externalIds","audits","a","occurred","parseFloat","createOptions","WithAuthz","saveSchema","upgrade","deleteSchema","loadSchema","saveNamespace","namespace","oldName","schemaName","deleteNamespace","saveRelationDefinition","relationDefinition","deleteRelationDefinition","createRelations","deleteRelationsForResources","resources","deleteResourceRelationsForResources","deleteRelationsForIds","relationQueries","whoCanAccess","resourceRelations","ignoreTargetSetRelations","targetsRelations","includeTargetSetRelations","whatCanTargetAccess","target","whatCanTargetAccessWithRelation","since","getTime","withSSOApplication","createOidcApplication","enabled","createSamlApplication","updateOidcApplication","updateSamlApplication","apps","withPassword","WithFGA","config","postWithOptionalCache","path","fgaCacheUrl","managementKey","url","controller","AbortController","timeoutId","setTimeout","abort","method","Authorization","projectId","JSON","stringify","signal","clearTimeout","tuples","loadResourcesDetails","resourceIdentifiers","resourcesDetails","saveResourcesDetails","deleteAllRelations","withInboundApplication","createApplication","updateApplication","patchApplication","deleteApplication","loadApplication","loadAllApplications","getApplicationSecret","rotateApplicationSecret","searchConsents","consents","deleteConsents","withOutboundApplication","app","appId","scopes","withDescoper","descopers","put","total","attributes","rbac","descoper","withManagementKey","reBac","nodeSdk","authManagementKey","publicKey","nodeHeaders","process","versions","node","authSdkConfig","baseHeaders","hooks","beforeRequest","requestConfig","concat","coreSdk","createSdk","logger","mgmtSdkConfig","baseConfig","mgmtHttpClient","createHttpClient","management","fgaConfig","client","project","tags","environment","listProjects","projects","request","files","accessKey","ssoApplication","inboundApplication","outboundApplication","sso","permission","group","audit","authz","fga","sdk","refresh","externalToken","header","kid","Error","parsedKey","parse","importJWK","e","error","publicKeys","then","json","Promise","all","reduce","acc","jwk","toString","fetchKeys","verifyOptions","clockTolerance","jwtVerify","getKey","payload","iss","split","pop","errors","JWTClaimValidationFailed","sessionToken","validateJwt","refreshToken","jwtResp","ok","sessionJwt","join","_e","_f","errorMessage","refreshTokenErr","validateSession","log","refreshSession","exchange","validatePermissions","validateTenantPermissions","getMatchedPermissions","getMatchedTenantPermissions","granted","every","perm","includes","filter","validateRoles","validateTenantRoles","getMatchedRoles","getMatchedTenantRoles","membership","wrapWith","RefreshTokenCookieName","SessionTokenCookieName","DescopeErrors","badRequest","missingArguments","invalidRequest","invalidArguments","wrongOTPCode","tooManyOTPAttempts","enchantedLinkPending","userNotFound"],"mappings":"0MAEkB,QAAlBA,EAAAC,WAAWC,eAAO,IAAAF,IAAlBC,WAAWC,QAAYA,EAAOA,SAE9B,MAGMC,EAAe,IAAIC,KAGvBA,EAAKC,SAASC,YAERA,GAAsB,iBAARA,YAEhBN,GAAAO,EAACD,GAAYE,+BAAAA,cAVK,UAWnB,IAGIC,EAAUC,SAAIN,ICIVO,EAAiB,CAACC,EAAmCC,KAChE,MAAMC,EAAQF,eAAAA,EAAQE,MAAMC,OAAO,iBAAiBF,cACpD,OAAOC,EAAQA,EAAM,GAAK,IAAI,EAQnBE,EACVC,GACDC,SAAUd,eACR,MAAMe,QAAaF,KAAMb,GAGzB,IAAKe,EAAKC,KACR,OAAOD,EAIT,IAAIE,EAA0BF,EAAKC,MAA/BE,WAAEA,GAAUD,EAAKE,EAAjBC,EAAAA,OAAAH,EAAA,CAAA,eACJ,MAAMI,EAAoB,GAjCP,IAA8BC,EA+CjD,OAZKJ,EASHG,EAAQE,KA3CZ,GCXoC,SDsDoBL,cA3C5BI,OADuBA,EA4CiBH,QA3CxC,EAAAG,EAASE,eAAgB,gBACnDF,aAAA,EAAAA,EAASG,eAAgB,aACjBH,aAAA,EAAAA,EAASI,aAAc,mCAiCZ,QAAb9B,EAAAmB,EAAKY,gBAAQ,IAAA/B,OAAA,EAAAA,EAAEgC,QAAQC,IAAI,iBAC7BX,EAAaX,EACE,QAAbJ,EAAAY,EAAKY,gBAAQ,IAAAxB,OAAA,EAAAA,EAAEyB,QAAQC,IAAI,cChDC,ODmD9BR,EAAQE,KAAoB,QAAfO,EAAAf,EAAKY,gBAAU,IAAAG,OAAA,EAAAA,EAAAF,QAAQC,IAAI,gBAMhCE,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAjB,GAAM,CAAAC,KAAWe,OAAAC,OAAAD,OAAAC,OAAA,GAAAjB,EAAKC,MAAM,CAAAE,aAAYG,aAAY,WAUpDY,EACdC,EACAC,EACAC,WAEA,MAAMC,EAAQD,EAC0C,QAApDjC,EAA6C,QAA7CP,EAAAsC,EAASI,MAAgC,eAAI,IAAA1C,OAAA,EAAAA,EAAAwC,UAAO,IAAAjC,OAAA,EAAAA,EAAGgC,GACvDD,EAASI,MAAMH,GACnB,OAAOI,MAAMC,QAAQH,GAASA,EAAQ,EACxC,CAQgB,SAAAI,EAA2BP,EAA8BE,SACvE,SAAmD,QAA1CxC,EAAAsC,EAASI,MAAgC,eAAC,IAAA1C,OAAA,EAAAA,EAAGwC,GACxD,CEtFA,IAAeM,EACP,CACJC,OAAQ,uBACRC,eAAgB,4BAChBC,YAAa,6BACbC,OAAQ,uBACRC,MAAO,sBACPC,WAAY,4BACZC,OAAQ,uBACRC,YAAa,6BACbC,mBAAoB,gCACpBC,KAAM,gBACNC,OAAQ,uBACRC,UAAW,sBACXC,OAAQ,uBACRC,gBAAiB,4BACjBC,iBAAkB,+BAClBC,aAAc,8BACdC,cAAe,+BACfC,YAAa,6BACbC,YAAa,6BACbC,kBAAmB,4BACnBC,cAAe,+BACfC,sBAAuB,uCACvBC,QAAS,gCACTC,QAAS,gCACTC,WAAY,mCACZC,WAAY,kCACZC,WAAY,kCACZC,cAAe,qCACfC,UAAW,kCACXC,aAAc,qCACdC,YAAa,6BACbC,qBAAsB,uCACtBC,kBAAmB,oCACnBC,eAAgB,gCAChBC,kBAAmB,gCACnBC,eAAgB,4BAChBC,mBAAoB,8BACpBC,yBAA0B,oCAC1BC,6BAA8B,wCAC9BC,qBAAsB,oCACtBC,2BAA4B,oCAC5BC,QAAS,yBA3CE1C,EA6CJ,CACP2C,WAAY,+BACZC,WAAY,+BACZC,MAAO,yBACPC,aAAc,yBACdC,eAAgB,mCAChBC,eAAgB,mCAChBC,iBAAkB,sCApDPjD,EAsDF,CACTC,OAAQ,4BACRS,KAAM,qBACNG,OAAQ,4BACRT,OAAQ,4BACR8C,WAAY,gCACZC,SAAU,8BACV5C,OAAQ,6BA7DGP,EA+DL,CACNC,OAAQ,yBACRG,OAAQ,yBACRG,OAAQ,yBACRG,KAAM,kBACN0C,SAAU,2BACVC,QAAS,sBACTC,UAAW,yBACXC,6BAA8B,2CAvEnBvD,EAyEG,CACdwD,WAAY,mCACZC,WAAY,mCACZC,WAAY,mCACZC,WAAY,mCACZpD,OAAQ,8BACRG,KAAM,4BACN2C,QAAS,8BAhFErD,EAkFO,CAClBC,OAAQ,iCACRG,OAAQ,iCACRC,MAAO,gCACPE,OAAQ,iCACRG,KAAM,+BACN2C,QAAS,gCACTO,OAAQ,iCACRC,OAAQ,kCA1FG7D,EA4Fe,CAC1BO,OAAQ,sCACRM,OAAQ,uCA9FGb,EAgGQ,CACnBC,OAAQ,+BACRG,OAAQ,+BACRG,OAAQ,+BACRG,KAAM,wBACN2C,QAAS,yBACTS,WAAY,0CACZC,mBAAoB,mCACpBC,iBAAkB,4CAClBC,yBAA0B,qCAC1BC,iBAAkB,gCAClBC,gBAAiB,2BA3GNnE,EA6GR,CACHoD,SAAU,wBACVgB,YAAa,4BACbC,SAAU,wBACVC,QAAS,uBACTC,WAAY,wBACZC,cAAe,4BACfC,KAAM,CACJC,UAAW,qBAEbC,KAAM,CACJD,UAAW,oBACXL,SAAU,+BAzHDrE,EA4HR,CACHI,OAAQ,sBACRwE,YAAa,uBACbC,kBAAmB,8BACnBC,OAAQ,uBACRC,OAAQ,uBACRC,WAAY,0BACZC,UAAW,0BACXC,gBAAiB,kCApINlF,EAsIH,CACRoD,SAAU,8BAvICpD,EAyID,CACVC,OAAQ,6BACRG,OAAQ,6BACRG,OAAQ,6BACR8C,QAAS,2BA7IErD,EA+IP,CACJC,OAAQ,uBACRG,OAAQ,uBACRG,OAAQ,uBACR8C,QAAS,oBACTxC,OAAQ,wBApJGb,EAsJP,CACJmF,KAAM,qBACN5E,OAAQ,uBACR6E,OAAQ,uBACRC,OAAQ,uBACRC,IAAK,qBA3JMtF,EA6JN,CACLoF,OAAQ,wBACRC,OAAQ,yBA/JGrF,EAiKN,CACLuF,cAAe,qBACfC,uBAAwB,4BACxBC,oBAAqB,0BApKVzF,EAsKN,CACLa,OAAQ,wBACR6E,YAAa,wBAxKF1F,EA0KN,CACL2F,WAAY,6BACZC,aAAc,+BACdC,WAAY,6BACZC,OAAQ,yBACRC,SAAU,2BACVC,OAAQ,yBACRC,SAAU,2BACVC,SAAU,2BACVC,SAAU,2BACVC,kBAAmB,oCACnBC,sCAAuC,6CACvCC,aAAc,wBACdC,IAAK,wBACLC,SAAU,6BACVC,QAAS,4BACTC,UAAW,8BACXC,mBAAoB,uCACpBC,YAAa,8BA5LF5G,EA8LR,CACH6G,OAAQ,sBACRC,UAAW,yBACXC,gBAAiB,gCACjBC,MAAO,qBACPC,cAAe,8BACfC,cAAe,+BApMJlH,EAsMH,CACRC,OAAQ,oBACRG,OAAQ,oBACRjB,IAAK,oBACLoB,OAAQ,oBACR4E,KAAM,0BA3MKnF,EA6ME,CACbC,OAAQ,yBACRG,OAAQ,yBACRM,KAAM,yBACNH,OAAQ,gCACRM,OAAQ,iCC7MN,SAAUsG,EAAuBC,GACrC,OAAOA,EAAMC,KAAKnK,IAAA,IAAAoK,MAAEA,GAAgBpK,EAANqK,EAAI7I,EAAAA,OAAAxB,EAAhB,WAAuB,sCACpCqK,GAAI,CACPC,UAAWF,GACX,GACJ,CC2DA,MAAMG,EAAYC,IAsThB,SAASC,EAAsBC,EAAiBhJ,GAC9C,MAAMiJ,EAAO,CACXD,WAiDF,YA9CsBE,IAAlBlJ,EAAQmJ,QACVF,EAAKE,MAAQnJ,EAAQmJ,YAEDD,IAAlBlJ,EAAQoJ,QACVH,EAAKG,MAAQpJ,EAAQoJ,YAEKF,IAAxBlJ,EAAQqJ,cACVJ,EAAKI,YAAcrJ,EAAQqJ,kBAEHH,IAAtBlJ,EAAQsJ,YACVL,EAAKK,UAAYtJ,EAAQsJ,gBAEAJ,IAAvBlJ,EAAQuJ,aACVN,EAAKM,WAAavJ,EAAQuJ,iBAEDL,IAAvBlJ,EAAQwJ,aACVP,EAAKO,WAAaxJ,EAAQwJ,iBAENN,IAAlBlJ,EAAQ0I,QACVO,EAAKL,UAAY5I,EAAQ0I,YAECQ,IAAxBlJ,EAAQyJ,cACVR,EAAKQ,YAAczJ,EAAQyJ,kBAEIP,IAA7BlJ,EAAQ0J,mBACVT,EAAKS,iBAAmB1J,EAAQ0J,uBAEVR,IAApBlJ,EAAQ2J,UACVV,EAAKU,QAAU3J,EAAQ2J,cAEKT,IAA1BlJ,EAAQ4J,gBACVX,EAAKW,cAAgB5J,EAAQ4J,oBAEDV,IAA1BlJ,EAAQ6J,gBACVZ,EAAKY,cAAgB7J,EAAQ6J,oBAELX,IAAtBlJ,EAAQ8J,YACVb,EAAKa,UAAY9J,EAAQ8J,gBAENZ,IAAjBlJ,EAAQ+J,OACVd,EAAKc,KAAO/J,EAAQ+J,WAECb,IAAnBlJ,EAAQgK,SACVf,EAAKe,OAAShK,EAAQgK,QAGjBf,CACR,CAiCD,MAAO,CACL5H,OAxXF,SACE2H,EACAiB,EACAb,EACAC,EACAX,EACAe,EACAC,EACAC,EACAC,EACAC,EACAP,EACAC,EACAC,EACAU,GAKA,MAAMjB,EACsB,iBAAnBgB,EACH,CACEjB,UACAG,MAAOc,EACPb,QACAC,cACAC,YACAC,aACAC,aACAZ,UAAWF,EACXe,cACAC,mBACAC,UACAC,gBACAC,gBACAK,mDAGAlB,WACGiB,GACH,CAAArB,UAAWqB,aAAA,EAAAA,EAAgBvB,MAC3BA,WAAOQ,IAEf,OAAOiB,oBACLrB,EAAWsB,KAAKhJ,EAAcC,OAAQ4H,IACrCvJ,GAASA,EAAKiJ,MAElB,EAoVCrH,eA3TF,SACE0H,EACAiB,EACAb,EACAC,EACAX,EACAe,EACAC,EACAC,EACAC,EACAC,EACAP,EACAC,EACAC,EACAU,GAKA,MAAMjB,EACsB,iBAAnBgB,EACH,CACEjB,UACAG,MAAOc,EACPb,QACAC,cACAC,YACAC,aACAC,aACAZ,UAAWF,EACXe,cACAC,mBACAC,UACAC,gBACAC,gBACAK,qBACAG,MAAM,GAET5J,OAAAC,OAAAD,OAAAC,OAAA,CACGsI,WACGiB,IACHrB,UAAWqB,aAAc,EAAdA,EAAgBvB,MAC3BA,WAAOQ,EACPmB,MAAM,IAEd,OAAOF,oBACLrB,EAAWsB,KAAKhJ,EAAcE,eAAgB2H,IAC7CvJ,GAASA,EAAKiJ,MAElB,EA2QC2B,OAxOF,SACEtB,EACAiB,EACAb,EACAC,EACAX,EACAe,EACAC,EACAC,EACAC,EACAC,EACAU,EACAC,EACAC,EACAnB,EACAC,EACAC,EACAU,EACAQ,GAKA,MAAMzB,EACsB,iBAAnBgB,EACH,CACEjB,UACAG,MAAOc,EACPb,QACAC,cACAC,YACAC,aACAC,aACAZ,UAAWF,EACXe,cACAa,QAAQ,EACRZ,mBACAC,UACAC,gBACAC,gBACAU,YACAC,WACAC,UACAP,qBACAQ,cAEHjK,OAAAC,OAAAD,OAAAC,OAAA,CACGsI,WACGiB,IACHrB,UAAWqB,aAAc,EAAdA,EAAgBvB,MAC3BA,WAAOQ,EACPoB,QAAQ,IAEhB,OAAOH,oBACLrB,EAAWsB,KAAKhJ,EAAcC,OAAQ4H,IACrCvJ,GAASA,EAAKiJ,MAElB,EAgLCgC,YAAa,CACXnC,EACA+B,EACAC,EACAC,EACAG,EACAF,IAEAP,oBACErB,EAAWsB,KAAKhJ,EAAcG,YAAa,CACzCiH,MAAOD,EAAuBC,GAC9B8B,QAAQ,EACRC,YACAC,WACAC,UACAG,kBACAF,gBAEDhL,GAASA,IAEd6B,YAAciH,GACZ2B,oBACErB,EAAWsB,KAAKhJ,EAAcG,YAAa,CACzCiH,MAAOD,EAAuBC,MAE/B9I,GAASA,IAEdkC,YAAciJ,GACZV,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAcQ,YAAa,CAAEiJ,aACjErJ,OAvLF,SACEwH,EACAiB,EACAb,EACAC,EACAX,EACAe,EACAC,EACAC,EACAC,EACAC,EACAP,EACAC,EACAC,EACAU,GAKA,MAAMjB,EACsB,iBAAnBgB,EACH,CACEjB,UACAG,MAAOc,EACPb,QACAC,cACAC,YACAC,aACAC,aACAZ,UAAWF,EACXe,cACAC,mBACAC,UACAC,gBACAC,gBACAK,mDAGAlB,WACGiB,GACH,CAAArB,UAAWqB,aAAA,EAAAA,EAAgBvB,MAC3BA,WAAOQ,IAEf,OAAOiB,oBACLrB,EAAWsB,KAAKhJ,EAAcI,OAAQyH,IACrCvJ,GAASA,EAAKiJ,MAElB,EAyIClH,MAtEF,SAAeuH,EAAiBhJ,GAC9B,MAAMiJ,EAAOF,EAAsBC,EAAShJ,GAE5C,OAAOmK,oBACLrB,EAAWrH,MAAML,EAAcK,MAAOwH,IACrCvJ,GAASA,EAAKiJ,MAElB,EAgECjH,WA1DF,SACE8G,GAEA,MAAMS,EAAO,CACXT,MAAOA,EAAMC,KAAKE,GAASI,EAAsBJ,EAAKK,QAASL,MAGjE,OAAOwB,oBACLrB,EAAWrH,MAAML,EAAcM,WAAYuH,IAC1CvJ,GAASA,GAEb,EAoDCiC,OAASqH,GACPmB,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAcO,OAAQ,CAAEqH,aAM5D8B,eAAiBC,GACfZ,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAcO,OAAQ,CAAEoJ,YAI5DlJ,mBAAoB,IAClBsI,EAAAA,kBAAkBrB,EAAWnH,OAAOP,EAAcS,qBACpDC,KAAOkH,GACLmB,oBACErB,EAAWvI,IAAIa,EAAcU,KAAM,CACjCkJ,YAAa,CAAEhC,cAEhBtJ,GAASA,EAAKiJ,OAQnBsC,aAAeF,GACbZ,oBACErB,EAAWvI,IAAIa,EAAcU,KAAM,CACjCkJ,YAAa,CAAED,aAEhBrL,GAASA,EAAKiJ,OAOnBuC,WAAalC,GACXmB,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAcW,OAAQ,CAAEiH,aAO5DmC,mBAAqBJ,GACnBZ,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAcW,OAAQ,CAAEgJ,YAO5D/I,UAAW,CACT6I,EACAO,IAEAjB,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcY,UAAW,CACvC6I,UACAO,yBAED1L,GAASA,EAAK8I,QAcnB9D,UAAW,CACT2G,EACA3C,EACA4C,EACAC,EACAC,EACAC,EACA/B,EACAgC,EACAC,EACAC,IAEAzB,oBACErB,EAAWsB,KAAKhJ,EAAca,OAAQ,CACpCoJ,YACAzC,UAAWF,EACX4C,QACAC,OACAC,gBACAC,eACA/B,mBACAgC,WACAC,SACAC,YAEDlM,GAASA,EAAK8I,QAEnBtG,gBAAkB2J,GAChB1B,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcc,gBACzBzB,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAmL,GACH,CAAAJ,cAAc,EACdD,eAAe,EACf5C,UAAWiD,EAAUnD,MACrBA,WAAOQ,MAERxJ,GAASA,EAAK8I,QAEnBvG,OAAS4J,GACP1B,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAca,OACzBxB,OAAAC,OAAAD,OAAAC,OAAA,GAAAmL,GACH,CAAAjD,UAAWiD,EAAUnD,MACrBA,WAAOQ,MAERxJ,GAASA,EAAK8I,QAanBrG,iBAAkB,CAChB6G,EACA8C,EACAC,IAEA5B,EAAAA,kBACErB,EAAWvI,IAAIa,EAAce,iBAAkB,CAC7C6I,YAAa,CACXhC,UACA8C,WACAE,kBAAkBD,eAAAA,EAAsBC,kBAAmB,OAAS,QACpEC,cAAcF,eAAAA,EAAsBE,cAAe,OAAS,YAG/DvM,GAASA,IAEd6E,SAAWyE,GACTmB,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcgB,aAAc,CAAE4G,UAASgB,OAAQ,aAC9DtK,GAASA,EAAKiJ,OAEnBrE,WAAa0E,GACXmB,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcgB,aAAc,CAAE4G,UAASgB,OAAQ,cAC9DtK,GAASA,EAAKiJ,OAEnBtG,cAAe,CAAC2G,EAAiBkD,IAC/B/B,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAciB,cAAe,CAAE2G,UAASkD,gBACvDxM,GAASA,EAAKiJ,OAEnBrG,YAAa,CACX0G,EACAG,EACAgD,EACAC,IAEAjC,oBACErB,EAAWsB,KAAKhJ,EAAckB,YAAa,CACzC0G,UACAG,QACAkD,SAAUF,EACVC,oBAED1M,GAASA,EAAKiJ,OAEnBpG,YAAa,CACXyG,EACAI,EACA+C,EACAC,IAEAjC,oBACErB,EAAWsB,KAAKhJ,EAAcmB,YAAa,CACzCyG,UACAI,QACAiD,SAAUF,EACVC,oBAED1M,GAASA,EAAKiJ,OAEnBnG,kBAAmB,CACjBwG,EACAK,EACAC,EACAC,EACAC,IAEAW,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcoB,kBAAmB,CAC/CwG,UACAK,cACAC,YACAC,aACAC,gBAED9J,GAASA,EAAKiJ,OAEnBlG,cAAe,CAACuG,EAAiBW,IAC/BQ,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcqB,cAAe,CAAEuG,UAASW,aACvDjK,GAASA,EAAKiJ,OAEnBjG,sBAAuB,CACrBsG,EACAsD,EACAC,IAEApC,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAcsB,sBAAuB,CACnDsG,UACAsD,eACAC,oBAED7M,GAASA,EAAKiJ,OAEnB6D,SAAU,CAACxD,EAAiBN,IAC1ByB,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcuB,QAAS,CAAEqG,UAASJ,UAAWF,KAC5DhJ,GAASA,EAAKiJ,OAEnB8D,SAAU,CAACzD,EAAiBN,IAC1ByB,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcwB,QAAS,CAAEoG,UAASJ,UAAWF,KAC5DhJ,GAASA,EAAKiJ,OAEnB+D,YAAa,CAAC1D,EAAiBN,IAC7ByB,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcyB,WAAY,CAAEmG,UAASJ,UAAWF,KAC/DhJ,GAASA,EAAKiJ,OAEnB1F,UAAW,CAAC+F,EAAiB2D,IAC3BxC,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAc6B,UAAW,CAAE+F,UAAS2D,cACnDjN,GAASA,EAAKiJ,OAEnBzF,aAAc,CAAC8F,EAAiB2D,IAC9BxC,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAc8B,aAAc,CAAE8F,UAAS2D,cACtDjN,GAASA,EAAKiJ,OAEnBiE,eAAgB,CACd5D,EACA2D,EACAjE,IAEAyB,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAcuB,QAAS,CAAEqG,UAAS2D,WAAU/D,UAAWF,KACtEhJ,GAASA,EAAKiJ,OAEnBkE,eAAgB,CACd7D,EACA2D,EACAjE,IAEAyB,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAcwB,QAAS,CAAEoG,UAAS2D,WAAU/D,UAAWF,KACtEhJ,GAASA,EAAKiJ,OAEnBmE,kBAAmB,CACjB9D,EACA2D,EACAjE,IAEAyB,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAcyB,WAAY,CAAEmG,UAAS2D,WAAU/D,UAAWF,KACzEhJ,GAASA,EAAKiJ,OAEnBoE,WAAY,CAAC/D,EAAiBc,IAC5BK,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAc2B,WAAY,CAAEiG,UAASc,eACpDpK,GAASA,EAAKiJ,OAEnBqE,WAAY,CAAChE,EAAiBc,IAC5BK,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAc0B,WAAY,CAAEkG,UAASc,eACpDpK,GAASA,EAAKiJ,OAEnBsE,cAAe,CAACjE,EAAiBc,IAC/BK,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAc4B,cAAe,CAAEgG,UAASc,eACvDpK,GAASA,EAAKiJ,OAcnBuE,uBAAwB,CACtBC,EACAnE,EACAoE,IAEAjD,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAcqC,mBAAoB,CAChD0J,iBACAnE,UACAoE,kBAED1N,GAASA,IAed2N,6BAA8B,CAC5BF,EACAnE,EACAsE,EACAF,IAEAjD,oBACErB,EAAWsB,KAAKhJ,EAAcsC,yBAA0B,CACtDyJ,iBACAnE,UACAuE,IAAKD,EACLF,kBAED1N,GAASA,IAcd8N,iCAAkC,CAChCxE,EACAsE,EACAF,IAEAjD,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAcuC,6BAA8B,CAC1DqF,UACAuE,IAAKD,EACLF,kBAED1N,GAASA,IAGdkE,qBAAsB,CACpBoF,EACAyE,EACAC,IAEAvD,oBACErB,EAAWsB,KAAKhJ,EAAcwC,qBAAsB,CAAEoF,UAASyE,eAAcC,aAC5EhO,GAASA,IAGdmE,2BAA4B,CAC1BmF,EACAL,EAQAgF,EACAC,EACAR,EACAM,IAEAvD,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAcyC,2BAA4B,CACxDmF,UACAL,OACAgF,gBACAC,gBACAR,eACAM,aAEDhO,GAASA,IAWd0D,qBAAsB,CAAC4F,EAAiB6E,IACtC1D,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAcgC,qBAAsB,CAAE4F,UAAS6E,cAC9DnO,GAASA,IAQd2D,kBAAmB,CAAC2F,EAAiB6E,IACnC1D,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAciC,kBAAmB,CAAE2F,UAAS6E,cAC3DnO,GAASA,IAWdyD,YAAa,CAAC6F,EAAiB6E,IAC7B1D,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAc+B,YAAa,CAAE6F,UAAS6E,cACrDnO,GAASA,IASd4D,eAAiB0F,GACfmB,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAckC,eAAgB,CAAE0F,aAC/CtJ,GAASA,IASd6D,kBAAoByF,GAClBmB,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcmC,kBAAmB,CAAEyF,aAClDtJ,GAASA,IASd8D,eAAiBwF,GACfmB,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcoC,eAAgB,CAAEwF,aAC/CtJ,GAASA,IAOdoE,QAAU+G,GACRV,oBACErB,EAAWsB,KAAKhJ,EAAc0C,QAAS+G,IACtCnL,GAASA,IAEf,ECx+BGoO,EAAchF,IAA4B,CAC9CzH,OAAQ,CACNlC,EACA4O,EACArE,EACAsE,EACAC,EACAC,IAEA/D,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAgBC,OAAQ,CACtClC,OACA4O,0BACArE,mBACAsE,aACAC,WACAC,YAGNC,aAAc,CACZC,EACAjP,EACA4O,EACArE,EACAsE,EACAC,EACAC,IAEA/D,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAgBC,OAAQ,CACtC+M,KACAjP,OACA4O,0BACArE,mBACAsE,aACAC,WACAC,YAGN1M,OAAQ,CACN4M,EACAjP,EACA4O,EACArE,EACAsE,EACAC,IAEA9D,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAgBI,OAAQ,CACtC4M,KACAjP,OACA4O,0BACArE,mBACAsE,aACAC,cAGNtM,OAAQ,CAACyM,EAAYC,IACnBlE,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAgBO,OAAQ,CAAEyM,KAAIC,aAClEvM,KAAOsM,GACLjE,oBACErB,EAAWvI,IAAIa,EAAgBU,KAAM,CACnCkJ,YAAa,CAAEoD,SAEhB1O,GAASA,IAEd+E,QAAS,IACP0F,EAAiBA,kBACfrB,EAAWvI,IAAIa,EAAgBqD,QAAS,CAAE,IACzC/E,GAASA,EAAK4O,UAEnB5J,UAAW,CACT6J,EACAC,EACAT,EACArE,EACA+E,IAEAtE,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAgBsD,UAAW,CACzC2G,UAAWkD,EACXG,YAAaF,EACbG,8BAA+BZ,EAC/BrE,mBACA+E,oBAED/O,GAASA,EAAK4O,UAEnBM,YAAcjC,GACZxC,oBACErB,EAAWvI,IAAIa,EAAgBoD,SAAU,CACvCwG,YAAa,CAAEoD,GAAIzB,MAEpBjN,GAASA,IAEdmP,kBAAmB,CAAClC,EAAkBnI,IACpC2F,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAgBoD,SAAQ/D,OAAAC,OAAAD,OAAAC,OAAA,GAAO8D,GAAQ,CAAEmI,aAAY,CAAA,IACzFhI,6BAA8B,CAC5BgI,EACAmC,EACAC,EACA5F,EACAuB,IAEAP,oBACErB,EAAWsB,KACThJ,EAAgBuD,6BAChB,CAAEgI,WAAUqC,WAAYF,EAAgBC,QAAO5F,QAAOuB,cACtD,CAAE,IAEHhL,GAASA,MChHVuP,EAAWnG,IAA4B,CAC3CtH,OAAQ,CACN0N,EACAzB,EACA0B,IAEAhF,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAaI,OAAQ,CAAE0N,MAAKzB,eAAc0B,qBAC9EnJ,YAAa,CACXoJ,EACApG,EACAqG,EACA5B,EACA6B,EACAH,IAEAhF,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAa4E,YAAa,CACxCoJ,iBACApG,UACAqG,kBACA5B,eACA6B,iBACAH,qBAGNlJ,kBAAmB,CACjBiJ,EACAzB,EACA6B,EACAH,IAEAhF,oBACErB,EAAWsB,KAAKhJ,EAAa6E,kBAAmB,CAC9CiJ,MACAzB,eACA6B,iBACAH,qBAGNjJ,OAAQ,CAAC8C,EAAiBoE,IACxBjD,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAa8E,sBAAU8C,WAAYoE,KACvEjH,OAAQ,CACN6C,EACAL,EACA4G,IAEApF,oBAAkBrB,EAAWsB,KAAKhJ,EAAa+E,OAAM1F,OAAAC,OAAA,CAAIsI,UAASL,QAAS4G,KAC7EnJ,WAAY,CACV4C,EACAL,EACA4G,IAEApF,oBACErB,EAAWsB,KAAKhJ,EAAagF,WAAU3F,OAAAC,OAAA,CAAIsI,UAASL,QAAS4G,KAEjElJ,UAAW,CACToH,EACA6B,EACAH,IAEAhF,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAaiF,UAAW,CAAEoH,eAAc6B,iBAAgBH,qBAE5EK,2BAA4B,CAC1BC,EACAC,EACAC,EACAC,EACAC,EACAC,IAEA3F,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAakF,gBAAiB,CAC5CmJ,SACAC,UACAC,WACAC,YACAC,kBACAC,iBClFFC,EAAkBjH,IAA4B,CAClDzH,OAAQ,CAAClC,EAAc6Q,IACrB7F,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAoBC,OAAQ,CAAElC,OAAM6Q,iBACxExO,OAAQ,CAACrC,EAAc8Q,EAAiBD,IACtC7F,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAoBI,OAAQ,CAAErC,OAAM8Q,UAASD,iBACjFrO,OAASxC,GACPgL,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAoBO,OAAQ,CAAExC,UAClEsF,QAAS,IACP0F,EAAiBA,kBACfrB,EAAWvI,IAAIa,EAAoBqD,QAAS,CAAE,IAC7C/E,GAASA,EAAKwQ,gBCVfC,EAAYrH,IAA4B,CAC5CzH,OAAQ,CACNlC,EACA6Q,EACAI,EACAzD,EACA0D,IAEAlG,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAcC,OAAQ,CACpClC,OACA6Q,cACAI,kBACAzD,WACA2D,QAASD,KAGf7O,OAAQ,CACNrC,EACA8Q,EACAD,EACAI,EACAzD,EACA0D,IAEAlG,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAcI,OAAQ,CACpCrC,OACA8Q,UACAD,cACAI,kBACAzD,WACA2D,QAASD,KAGf1O,OAAQ,CAACxC,EAAcwN,IACrBxC,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAcO,OAAQ,CAAExC,OAAMwN,cAClElI,QAAS,IACP0F,EAAiBA,kBACfrB,EAAWvI,IAAIa,EAAcqD,QAAS,CAAE,IACvC/E,GAASA,EAAKgJ,QAEnBzG,OAASjC,GACPmK,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAca,OAAQjC,EAAS,CAAA,IAC9CN,GAASA,EAAKgJ,UCjDf6H,EAAazH,IAA4B,CAM7CnC,cAAgBgG,GACdxC,EAAiBA,kBAAUrB,EAAWsB,KAAKhJ,EAAeuF,cAAe,CAAEgG,cAS7E/F,uBAAwB,CACtB+F,EACA9B,EACA2F,IAEArG,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAewF,uBAAwB,CAAE+F,WAAU6D,WAAU3F,aASjFhE,oBAAqB,CAAC8F,EAAkB8D,IACtCtG,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAeyF,oBAAqB,CAAE8F,WAAU8D,eCzBtE,SAASC,EAA0BhR,WACjC,MAAMiR,EAAgBjR,EAgBtB,OAfIiR,EAAc9K,OAChB8K,EAAc9K,KACTpF,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAiQ,EAAc9K,MAAI,CACrB+K,iBAAkBD,EAAc9K,KAAKgL,yBAEhCF,EAAc9K,KAAKgL,kBAEN,UAAlBF,EAAc5K,YAAI,IAAAzH,OAAA,EAAAA,EAAEwS,iBACtBH,EAAc5K,KAAK+K,cAAkC,UAAlBH,EAAc5K,YAAI,IAAAlH,OAAA,EAAAA,EAAEiS,cAAcrI,KAAKsI,IACxE,MAAMC,EAAKD,EAGX,OAFAC,EAAGC,SAAWD,EAAGE,KAAK/R,YACf6R,EAAGE,KACHF,CAAE,KAGNL,CACT,CASA,MAAMQ,EAAmBrI,IAA4B,CAInD8F,YAAcjC,GACZxC,oBACErB,EAAWvI,IAAIa,EAAaoD,SAAU,CACpCwG,YAAa,CAAE2B,eAEhBjN,GAASA,IAEd0R,YAAa,CACXzE,EACAoC,EACA1F,IAEAc,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAaoE,YAC3B/E,OAAAC,OAAAD,OAAAC,OAAA,CAAAiM,YACIoC,EAAQ,CAAEA,SAAU,CAAA,GAAG,CAC3B1F,kBAED3J,GAASgR,EAA0BhR,KAExC2R,eAAgB,CAAC1E,EAAkBoC,IACjC5E,EAAiBA,kBACfrB,EAAWnH,OAAOP,EAAaoD,SAAU,CACvCwG,2BAAe2B,YAAcoC,EAAQ,CAAEA,SAAU,OAMvDF,kBAAmB,CACjBlC,EACA2E,EACAC,EACAC,EACAC,EACAC,IAEAvH,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAaoD,SAAU,CACrCmI,WACA2E,SACAE,WACAD,UACAE,cACAC,aAMNC,kBAAmB,CACjBhF,EACAiF,EACAH,EACAC,IAEAvH,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAaqE,SAAU,CAAEkH,WAAUiF,iBAAgBH,cAAaC,aAKpFG,iBAAkB,CAChBlF,EACAmF,EACAlB,IAEAzG,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAasE,QAAS,CAAEiH,WAAUmF,eAAclB,sBAEpEmB,sBAAuB,CACrBpF,EACAnI,EACAkN,EACA3C,KAEA,MAAM4B,EAAqBlQ,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAA8D,GAAU,CAAAqM,gBAAiBrM,EAASoM,mBAE/D,cADOD,EAAcC,iBACdzG,EAAiBA,kBACtBrB,EAAWsB,KAAKhJ,EAAayE,KAAKC,UAChCrF,OAAAC,OAAA,CAAAiM,WACAnI,SAAUmM,EACVe,WACI3C,EAAQ,CAAEA,SAAU,KAE3B,EAEHiD,sBAAuB,CACrBrF,EACAnI,EACAyN,EACAP,EACA3C,IAEA5E,oBACErB,EAAWsB,KAAKhJ,EAAa2E,KAAKD,UAASrF,OAAAC,OAAA,CACzCiM,WACAnI,WACAyN,cACAP,WACI3C,EAAQ,CAAEA,SAAU,CAAA,KAG9BmD,wBAAyB,CACvBvF,EACAnI,EACAyN,EACAP,EACA3C,IAEA5E,oBACErB,EAAWsB,KAAKhJ,EAAa2E,KAAKN,SAAQhF,OAAAC,OAAA,CACxCiM,WACAnI,WACAyN,cACAP,WACI3C,EAAQ,CAAEA,SAAU,CAAA,KAG9BoD,aAAc,CAACxF,EAAkBoC,IAC/B5E,EAAiBA,kBACfrB,EAAWvI,IAAIa,EAAauE,WAAY,CACtCqF,2BAAe2B,YAAcoC,EAAQ,CAAEA,SAAU,OAElDrP,GAASgR,EAA0BhR,KAExC0S,gBAAkBzF,GAChBxC,oBACErB,EAAWvI,IAAIa,EAAawE,cAAe,CACzCoF,YAAa,CAAE2B,eAEhBjN,GA9IP,SAAsCA,GACpC,MAAMiR,EAAgBjR,EAAK2S,YACrBC,EAAM,GAEZ,OADA3B,EAAchS,SAAS4T,GAAYD,EAAIrS,KAAKyQ,EAA0B6B,MAC/DD,CACT,CAyIgBE,CAA6B9S,OClKvC+S,EAAiB3J,IAA4B,CAajDzH,OAAQ,CACNlC,EACA6P,EACAtG,EACA4F,EACAvD,EACA0C,EACAuC,EACA0C,IAEAvI,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAmBC,OAAQ,CACzClC,OACA6P,aACApG,UAAWF,EACXiK,WAAYrE,EACZvD,SACA0C,eACAuC,cACA0C,kBAQN5Q,KAAOsM,GACLjE,oBACErB,EAAWvI,IAAIa,EAAmBU,KAAM,CACtCkJ,YAAa,CAAEoD,SAEhB1O,GAASA,EAAKkT,MAOnBlO,UAAY2G,GACVlB,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAmBa,OAAQ,CAAEoJ,eAC5C3L,GAASA,EAAKmT,OAanBrR,OAAQ,CACN4M,EACAjP,EACA6Q,EACAtH,EACA4F,EACAb,EACAiF,IAEAvI,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAmBI,OAAQ,CACzC4M,KACAjP,OACA6Q,cACApH,UAAWF,EACXiK,WAAYrE,EACZb,eACAiF,kBAEDhT,GAASA,EAAKkT,MAOnBtO,WAAa8J,GACXjE,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAmBkD,WAAY,CAAE8J,QAKrE7J,SAAW6J,GACTjE,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAmBmD,SAAU,CAAE6J,QAKnEzM,OAASyM,GACPjE,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAmBO,OAAQ,CAAEyM,UC5G7D0E,EAAYhK,IAA4B,CAC5CvC,KAAM,IACJ4D,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAcmF,KAAM,CAAA,IACxD5E,OAASoR,GACP5I,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAcO,OAAQ,CAAE4M,IAAKwE,KACjEvM,OAASwM,GACP7I,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAcoF,OAAQ,CAAEwM,YAC5DvM,OAAQ,CAACuM,EAAgBC,EAAYC,IACnC/I,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAcqF,OAAQ,CAAEuM,SAAQC,OAAMC,aAC1ExM,IAAK,CACHsM,EACAhT,IAEAmK,oBACErB,EAAWsB,KAAKhJ,EAAcsF,IAAK,CAAEsM,SAAQhT,aAC5CN,GAAUA,eAAAA,EAAoCyT,WCtB/CC,EAAatK,IAA4B,CAC7CtC,OAAQ,IACN2D,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAeoF,OAAQ,CAAA,IAC3DC,OAAS4M,GACPlJ,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAeqF,OAAQ,CAAE4M,aCJzDC,EAAaxK,IAA4B,CAM7C7G,OAASsR,IACP,MAAMtK,EAAYxI,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAA6S,GAAe,CAAAC,YAAaD,EAAc/C,WAE5D,cADOvH,EAAKuH,SACLrG,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAea,OAAQgH,IAAQvJ,GACtEA,aAAA,EAAAA,EAAM+T,OAAOhL,KAAKiL,IAChB,MAAMpB,EACD7R,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAgT,IACHC,SAAUC,WAAWF,EAAEC,UACvBnD,SAAUkD,EAAEF,cAGd,cADOlB,EAAIkB,YACJlB,CAAG,KAEb,EAOHxL,YAAc+M,IACZ,MAAM5K,EAAIxI,OAAAC,OAAA,CAAA,EAAQmT,GAClB,OAAO1J,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAe0F,YAAamC,GAAM,ICpBzE6K,EAAahL,IAA4B,CAU7CiL,WAAY,CAAC9L,EAAqB+L,IAChC7J,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAe2F,WAAY,CAAEkB,SAAQ+L,aAMzEC,aAAc,IACZ9J,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAe4F,aAAc,CAAA,IAMjEkN,WAAY,IACV/J,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAe6F,WAAY,CAAE,IAAIvH,GAASA,EAAKuI,SAUnFkM,cAAe,CACbC,EACAC,EACAC,IAEAnK,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAe8F,OAAQ,CAAEkN,YAAWC,UAASC,gBASjFC,gBAAiB,CAACpV,EAAcmV,IAC9BnK,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAe+F,SAAU,CAAEhI,OAAMmV,gBAUrEE,uBAAwB,CACtBC,EACAL,EACAC,EACAC,IAEAnK,oBACErB,EAAWsB,KAAKhJ,EAAegG,OAAQ,CACrCqN,qBACAL,YACAC,UACAC,gBAYNI,yBAA0B,CACxBvV,EACAiV,EACAE,IAEAnK,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAeiG,SAAU,CAAElI,OAAMiV,YAAWE,gBAOhFK,gBAAkBzM,GAChBiC,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAekG,SAAU,CAAEY,eAO/DC,gBAAkBD,GAChBiC,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAemG,SAAU,CAAEW,eAS/D0M,4BAA8BC,GAC5B1K,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAeoG,kBAAmB,CAAEqN,eAQxEC,oCAAsCD,GACpC1K,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAeqG,sCAAuC,CAAEoN,eAQ5EE,sBAAwBxG,GACtBpE,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAeoG,kBAAmB,CAAEqN,UAAWtG,KAOnF7G,aACEsN,GAEA7K,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAesG,aAAc,CAAEsN,qBAC9CtV,GAASA,EAAKsV,kBAUnBC,aAAc,CACZrN,EACA6M,EACAL,IAEAjK,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAeuG,IAAK,CAAEC,WAAU6M,qBAAoBL,eACnE1U,GAASA,EAAKmI,UASnBqN,kBAAmB,CACjBtN,EACAuN,GAA2B,IAE3BhL,oBACErB,EAAWsB,KAAKhJ,EAAewG,SAAU,CAAEA,WAAUuN,8BACpDzV,GAASA,EAAKwI,YASnBkN,iBAAkB,CAChBvN,EACAwN,GAA4B,IAE5BlL,oBACErB,EAAWsB,KAAKhJ,EAAeyG,QAAS,CAAEA,UAASwN,+BAClD3V,GAASA,EAAKwI,YAQnBoN,oBAAsBC,GACpBpL,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAe0G,UAAW,CAAEyN,YAC3C7V,GAASA,EAAKwI,YAWnBsN,gCAAiC,CAC/BD,EACAd,EACAL,IAEAjK,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAe2G,mBAAoB,CAAEwN,SAAQd,qBAAoBL,eAChF1U,GAASA,EAAKmV,UAAUpM,KAAKb,IAAgB,CAAQA,iBAS1DI,YAAcyN,GACZtL,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAe4G,YAAa,CAAEyN,MAAOA,EAAQA,EAAMC,UAAY,KAC9EhW,GAASA,MCxOViW,EAAsB7M,IAA4B,CACtD8M,sBACE5V,UAEA,OAAAmK,oBACErB,EAAWsB,KAAKhJ,EAAwBwD,WAAUnE,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAC7CV,GACH,CAAA6V,QAA4B,QAAnBvX,EAAA0B,EAAQ6V,eAAW,IAAAvX,GAAAA,KAE/B,EACHwX,sBACE9V,UAEA,OAAAmK,oBACErB,EAAWsB,KAAKhJ,EAAwByD,WAAUpE,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAC7CV,GACH,CAAA6V,QAA4B,QAAnBvX,EAAA0B,EAAQ6V,eAAW,IAAAvX,GAAAA,KAE/B,EACHyX,sBACE/V,GAEAmK,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAwB0D,WAAiBrE,OAAAC,OAAA,CAAA,EAAAV,KAC7EgW,sBACEhW,GAEAmK,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAwB2D,WAAiBtE,OAAAC,OAAA,CAAA,EAAAV,KAC7E2B,OAASyM,GACPjE,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAwBO,OAAQ,CAAEyM,QACtEtM,KAAOsM,GACLjE,oBACErB,EAAWvI,IAAIa,EAAwBU,KAAM,CAC3CkJ,YAAa,CAAEoD,SAEhB1O,GAASA,IAEd+E,QAAS,IACP0F,EAAiBA,kBACfrB,EAAWvI,IAAIa,EAAwBqD,QAAS,CAAE,IACjD/E,GAASA,EAAKuW,SChDfC,EAAgBpN,IAA4B,CAChD8F,YAAcjC,GACZxC,oBACErB,EAAWvI,IAAIa,EAAkBoD,SAAU,CACzCwG,YAAa,CAAE2B,eAEhBjN,GAASA,IAEdmP,kBAAmB,CAAClC,EAAkBnI,IACpC2F,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAkBoD,wCAAeA,GAAQ,CAAEmI,iBCC3EwJ,EAAU,CAACrN,EAAwBsN,KACvC,MAAMC,EAAwB7W,MAAO8W,EAAcrN,KACjD,IAAImN,aAAA,EAAAA,EAAQG,cAAeH,EAAOI,cAAe,CAC/C,MAAMC,EAAM,GAAGL,EAAOG,cAAcD,IAEpC,IACE,MAAMI,EAAa,IAAIC,gBACjBC,EAAYC,YAAW,IAAMH,EAAWI,SATrB,KAWnBzW,QAAiBrB,EAAMyX,EAAK,CAChCM,OAAQ,OACRzW,QAAOG,OAAAC,OAAAD,OAAAC,OAAA,GACF0V,EAAO9V,SAAO,CACjB,eAAgB,mBAChB0W,cAAe,UAAUZ,EAAOa,aAAab,EAAOI,gBACpD,uBAAwBJ,EAAOa,YAEjChO,KAAMiO,KAAKC,UAAUlO,GACrBmO,OAAQV,EAAWU,SAIrB,OADAC,aAAaT,GACNvW,CAGR,CAFC,MAAM/B,GACN,OAAOwK,EAAWsB,KAAKkM,EAAMrN,EAC9B,CACF,CACD,OAAOH,EAAWsB,KAAKkM,EAAMrN,EAAK,EAGpC,MAAO,CAQL8K,WAAa9L,GACXkC,oBAAkBkM,EAAsBjV,EAAa6G,OAAQA,IAM/DgM,aAAc,IACZ9J,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAe4F,aAAc,CAAA,IAOjE2N,gBAAkBzM,GAChBiC,EAAiBA,kBAACkM,EAAsBjV,EAAa8G,UAAW,CAAEoP,OAAQpP,KAU5EC,gBAAkBD,GAChBiC,EAAiBA,kBAACkM,EAAsBjV,EAAa+G,gBAAiB,CAAEmP,OAAQpP,KAWlFE,MAAQF,GACNiC,EAAAA,kBACEkM,EAAsBjV,EAAagH,MAAO,CAAEkP,OAAQpP,KACnDxI,GAASA,EAAK4X,SAOnBC,qBACEC,GAEArN,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAaiH,cAAe,CAAEmP,yBAC7C9X,GAASA,EAAK+X,mBAOnBC,qBAAuBD,GACrBtN,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAakH,cAAe,CAAEmP,sBAOlEE,mBAAoB,IAClBxN,EAAAA,kBAAkBrB,EAAWnH,OAAOP,EAAa8G,YACpD,ECtGG0P,EAA0B9O,IAA4B,CAC1D+O,kBACE7X,GAEAmK,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAA4BC,OACvCZ,OAAAC,OAAA,CAAA,EAAAV,KAGT8X,kBACE9X,GAEAmK,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAA4BI,OAAaf,OAAAC,OAAA,CAAA,EAAAV,KAC7E+X,iBACE/X,GAEAmK,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAA4BK,MAAYhB,OAAAC,OAAA,CAAA,EAAAV,KAC5EgY,kBAAoB5J,GAClBjE,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAA4BO,OAAQ,CAAEyM,QAC1E6J,gBAAkB7J,GAChBjE,oBACErB,EAAWvI,IAAIa,EAA4BU,KAAM,CAC/CkJ,YAAa,CAAEoD,SAEhB1O,GAASA,IAEdwY,oBAAqB,IACnB/N,EAAiBA,kBACfrB,EAAWvI,IAAIa,EAA4BqD,QAAS,CAAE,IACrD/E,GAASA,EAAKuW,OAEnBkC,qBAAuB/J,GACrBjE,oBACErB,EAAWvI,IAAIa,EAA4B4D,OAAQ,CACjDgG,YAAa,CAAEoD,SAEhB1O,GAASA,IAEd0Y,wBAA0BhK,GACxBjE,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAA4B6D,OAAQ,CAAEmJ,QAC1EiK,eACErY,GAEAmK,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAoCa,OAAMxB,OAAAC,OAAA,CAAA,EAAOV,KAChEN,GAASA,EAAK4Y,WAEnBC,eAAiBvY,GACfmK,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAoCO,OAAalB,OAAAC,OAAA,CAAA,EAAAV,OCjDjFwY,EAA2B1P,IAA4B,CAC3D+O,kBACEY,GAEAtO,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAA6BC,OAAMZ,OAAAC,OAAA,CAAA,EAC9C+X,KAEJ/Y,GAASA,EAAK+Y,MAEnBX,kBACEW,GAEAtO,oBACErB,EAAWsB,KAAKhJ,EAA6BI,OAAQ,CACnDiX,SAED/Y,GAASA,EAAK+Y,MAEnBT,kBAAoB5J,GAClBjE,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAA6BO,OAAQ,CAAEyM,QAC3E6J,gBAAkB7J,GAChBjE,EAAiBA,kBACfrB,EAAWvI,IAAI,GAAGa,EAA6BU,QAAQsM,MACtD1O,GAASA,EAAK+Y,MAEnBP,oBAAqB,IACnB/N,EAAiBA,kBACfrB,EAAWvI,IAAIa,EAA6BqD,QAAS,CAAE,IACtD/E,GAASA,EAAKuW,OAEnB9Q,mBAAoB,CAClBuT,EACA3N,EACA4N,EACA3Y,EACA2M,IAEAxC,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAA6B+D,mBAAoB,CAC/DuT,QACA3N,SACA4N,SACA3Y,UACA2M,cAEDjN,GAASA,EAAKsB,QAEnBkE,WAAY,CACVwT,EACA3N,EACA4B,EACA3M,IAEAmK,oBACErB,EAAWsB,KAAKhJ,EAA6B8D,WAAY,CACvDwT,QACA3N,SACA4B,WACA3M,aAEDN,GAASA,EAAKsB,QAEnBqE,yBAA0B,CACxBqT,EACA/L,EACAgM,EACA3Y,IAEAmK,oBACErB,EAAWsB,KAAKhJ,EAA6BiE,yBAA0B,CACrEqT,QACA/L,WACAgM,SACA3Y,aAEDN,GAASA,EAAKsB,QAEnBoE,iBAAkB,CAChBsT,EACA/L,EACA3M,IAEAmK,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAA6BgE,iBAAkB,CAC7DsT,QACA/L,WACA3M,aAEDN,GAASA,EAAKsB,QAEnBsE,iBAAkB,CAACoT,EAAgB3N,IACjCZ,EAAiBA,kBACfrB,EAAWnH,OAAOP,EAA6BkE,iBAAkB,CAC/D0F,YAAa,CAAE0N,QAAO3N,aAG5BxF,gBAAkB6I,GAChBjE,oBACErB,EAAWnH,OAAOP,EAA6BmE,gBAAiB,CAC9DyF,YAAa,CAAEoD,WCjGjBwK,EAAgB9P,IAA4B,CAMhDzH,OAASwX,GACP1O,oBAAkBrB,EAAWgQ,IAAI1X,EAAkBC,OAAQ,CAAEwX,eAAenZ,IAAU,CACpFmZ,UAAWnZ,EAAKmZ,UAChBE,MAAOrZ,EAAKqZ,UAUhBvX,OAAQ,CACN4M,EACA4K,EACAC,IAEA9O,EAAAA,kBACErB,EAAWrH,MAAML,EAAkBI,OAAQ,CAAE4M,KAAI4K,aAAYC,UAC5DvZ,GAASA,EAAKwZ,WAQnBpX,KAAOsM,GACLjE,EAAiBA,kBACfrB,EAAWvI,IAAIa,EAAkBb,IAAK,CAAEyK,YAAa,CAAEoD,SACtD1O,GAASA,EAAKwZ,WAOnBvX,OAASyM,GACPjE,oBAAkBrB,EAAWnH,OAAOP,EAAkBO,OAAQ,CAAEqJ,YAAa,CAAEoD,SAMjF7H,KAAM,IACJ4D,oBAAkBrB,EAAWsB,KAAKhJ,EAAkBmF,OAAQ7G,IAAU,CACpEmZ,UAAWnZ,EAAKmZ,UAChBE,MAAOrZ,EAAKqZ,YCxEZI,EAAqBrQ,IAA4B,CACrDzH,OAAQ,CACNlC,EACAia,EACApJ,EACAJ,EACA8C,IAEAvI,EAAiBA,kBACfrB,EAAWgQ,IAAI1X,EAAuBC,OAAQ,CAC5ClC,OACA6Q,cACAJ,YACA8C,eACA0G,WAIN5X,OAAQ,CACN4M,EACAjP,EACA6Q,EACAhG,EACA0I,IAEAvI,EAAiBA,kBACfrB,EAAWrH,MAAML,EAAuBI,OAAQ,CAC9C4M,KACAjP,OACA6Q,cACA0C,eACA1I,YAEDtK,GAASA,EAAKkT,MAGnBjR,OAAS4M,GACPpE,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAuBO,OAAQ,CAAE4M,SAErEzM,KAAOsM,GACLjE,EAAiBA,kBACfrB,EAAWvI,IAAIa,EAAuBU,KAAM,CAAEkJ,YAAa,CAAEoD,SAC5D1O,GAASA,EAAKkT,MAGnB3Q,OAAQ,IACNkI,EAAAA,kBAAkBrB,EAAWvI,IAAIa,EAAuBa,SAAUvC,GAASA,EAAKmT,SCRpF,MAAMwG,GAAW/a,eAAAgb,kBACfA,EAAiB9C,cACjBA,EAAa+C,UACbA,EAAShD,YACTA,GAAWjY,EACR8X,EALYtW,EAAAA,OAAAxB,EAAA,CAAA,oBAAA,gBAAA,YAAA,gBAOf,MAAMkb,EAAc,CAClB,qBAAsB,SACtB,8BAAiD,QAAnB3a,EAAA,OAAA4a,cAAA,IAAAA,aAAA,EAAAA,QAASC,gBAAU,IAAA7a,OAAA,EAAAA,EAAA8a,OAAQ,GACzD,wBAAyB,SAGrBC,+BACJ5a,MAAAA,GACGoX,GACH,CAAAyD,2CACKzD,EAAOyD,aACPL,GAELM,MAAKrZ,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EACA0V,EAAO0D,OACV,CAAAC,cAAe,CAEZC,IACKV,IAEFU,EAAchZ,MAASgZ,EAAchZ,MAEjC,GAAGgZ,EAAchZ,SAASsY,IAD1BA,GAICU,IAETC,QAAmB,QAAZzZ,EAAA4V,EAAO0D,aAAK,IAAAtZ,OAAA,EAAAA,EAAEuZ,gBAAiB,QAGtCG,EAAUC,UAAUP,IAEpB3C,UAAEA,EAASmD,OAAEA,GAAWhE,EAExBvD,EAA6C,CAAA,EAgC7CwH,EACJ5Z,OAAAC,OAAAD,OAAAC,OAAA,CAAA1B,MAAAA,GACGoX,GAAM,CACTkE,WAAY,CACVT,2CACKzD,EAAOyD,aACPL,IAGPM,MACKrZ,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAA0V,EAAO0D,OAAK,CACfC,cAAe,CAEZC,IAECA,EAAchZ,MAAQwV,EACfwD,IAETC,QAAmB,QAAZta,EAAAyW,EAAO0D,aAAK,IAAAna,OAAA,EAAAA,EAAEoa,gBAAiB,QAGtCQ,EAAiBC,mBAAiBH,GAClCI,GCjHoCC,EDiHQ,CAChDnE,cACAC,gBACAS,YACA3W,QAASkZ,GCrH0D,CACrE7Q,KAAME,EADgB8R,EDiHYJ,GC/GlCK,SCVmB9R,EDUE6R,ECV0B,CAK/C5W,WAAa5E,GACXgL,oBACErB,EAAWsB,KAAKhJ,EAAiB2C,WAAY,CAC3C5E,UAQN6E,WAAa6W,GACX1Q,oBACErB,EAAWsB,KAAKhJ,EAAiB4C,WAAY,CAC3C6W,UAYN5W,MAAO,CACL9E,EACA2b,EACAD,IAEA1Q,EAAAA,kBACErB,EAAWsB,KAAKhJ,EAAiB6C,MAAO,CACtC9E,OACA2b,cACAD,UAQNE,aAAcvb,SACZ2K,EAAiBA,kBACfrB,EAAWsB,KAAKhJ,EAAiB8C,aAAc,KAC9CxE,GACCA,EAAKsb,SAASvS,KAAI,EAAG2F,KAAIjP,OAAM2b,cAAaD,WAAY,CACtDzM,KACAjP,OACA2b,cACAD,aAqBR1W,eAAgB,IACdgG,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAiB+C,eAAgB,CAAA,IAuBrEC,eAAiB6W,GACf9Q,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAiBgD,eAAgB6W,IAqBrE5W,iBACE4W,GAEA9Q,EAAAA,kBAAkBrB,EAAWsB,KAAKhJ,EAAiBiD,iBAAkB4W,IAKvEzU,OAAQ,IACN2D,EAAiBA,kBAACrB,EAAWsB,KAAKhJ,EAAiB+C,eAAgB,CAAE,IAAIzE,GAASA,EAAKwb,QAKzFzU,OAASyU,GACP/Q,oBACErB,EAAWsB,KAAKhJ,EAAiBgD,eAAgB,CAC/C8W,aDjINC,UAAW1I,EAAckI,GACzB7Z,OAAQgN,EAAW6M,GACnBS,eAAgBzF,EAAmBgF,GACnCU,mBAAoBzD,EAAuB+C,GAC3CW,oBAAqB9C,EAAwBmC,GAC7CY,IAAKpK,EAAgBwJ,GACrBzL,IAAKD,EAAQ0L,GACba,WAAYzL,EAAe4K,GAC3B9M,SAAUqI,EAAayE,GACvBzJ,KAAMf,EAASwK,GACfc,MAAOlL,EAAUoK,GACjB1H,KAAMH,EAAS6H,GACftH,MAAOD,EAAUuH,GACjBe,MAAOpI,EAAUqH,GACjBgB,MAAO7H,EAAU6G,GACjBiB,IAAKzF,EAAQwE,EAAQD,GACrBxB,SAAUN,EAAa+B,GACvBnE,cAAe2C,EAAkBwB,KApBZ,IAACA,EAAoBD,ECRvB5R,EFgInB,MAAM+S,iCACD3B,GAAO,CAGV4B,QAAStc,MAAOwB,EAAgB+a,IAC9B7B,EAAQ4B,QAAQ9a,OAAOkI,EAAW6S,GAOpCtB,aAGAjb,aAAawc,GACX,KAAKA,aAAA,EAAAA,EAAQC,KAAK,MAAMC,MAAM,gCAE9B,GAAIrJ,EAAKmJ,EAAOC,KAAM,OAAOpJ,EAAKmJ,EAAOC,KAKzC,GAFAxb,OAAOC,OAAOmS,OA/EArT,WAChB,GAAI+Z,EACF,IACE,MAAM4C,EAAYjF,KAAKkF,MAAM7C,GACvB3G,QAAYyJ,YAAUF,GAC5B,MAAO,CACL,CAACA,EAAUF,KAAMrJ,EAKpB,CAHC,MAAO0J,GAEP,MADAlC,SAAAA,EAAQmC,MAAM,0CAA2CD,GACnD,IAAIJ,MAAM,sCAAsCI,IACvD,CAGH,MAGME,SAHoBtC,EAAQpR,WAC/BvI,IAAI,WAAW0W,KACfwF,MAAMhd,GAASA,EAAKid,UACe7J,KACtC,OAAK5R,MAAMC,QAAQsb,UACQG,QAAQC,IACjCJ,EAAW/T,KAAIjJ,MAAOoT,GAAQ,CAACA,EAAIqJ,UAAWI,EAAAA,UAAUzJ,QAGtCiK,QAClB,CAACC,GAAMb,EAAKc,KAAUd,EAAWxb,OAAAC,OAAAD,OAAAC,OAAA,CAAA,EAAAoc,IAAK,CAACb,EAAIe,YAAaD,IAAQD,GAChE,CAAE,GAPmC,EAQtC,EAqD2BG,KAErBpK,EAAKmJ,EAAOC,KAAM,MAAMC,MAAM,gCAEnC,OAAOrJ,EAAKmJ,EAAOC,IACpB,EAQDzc,kBAAkB0P,EAAalP,SAE7B,MAAMkd,EAAyC,CAAEC,eAAgB,IAC7Dnd,aAAA,EAAAA,EAAS2P,YAAUuN,EAAcvN,SAAW3P,EAAQ2P,UACxD,MACM3O,SADYoc,YAAUlO,EAAK2M,EAAIwB,OAAQH,IAC3BI,QAElB,GAAItc,IACFA,EAAMuc,IAAe,QAATjf,EAAA0C,EAAMuc,WAAG,IAAAjf,OAAA,EAAAA,EAAEkf,MAAM,KAAKC,MAC9Bzc,EAAMuc,MAAQtG,GAEhB,MAAM,IAAIyG,EAAMA,OAACC,yBACf,+BACA,MACA,gBAKN,MAAO,CAAEzO,MAAKlO,QACf,EAQDxB,sBACEoe,EACA5d,GAEA,IAAK4d,EAAc,MAAM1B,MAAM,4CAE/B,IAEE,aADoBL,EAAIgC,YAAYD,EAAc5d,EAMnD,CAJC,MAAOuc,GAGP,MADAnC,SAAAA,EAAQmC,MAAM,4BAA6BA,GACrCL,MAAM,qCAAqCK,IAClD,CACF,EAUD/c,qBACEse,EACA9d,mBAEA,IAAK8d,EAAc,MAAM5B,MAAM,kDAE/B,UACQL,EAAIgC,YAAYC,GACtB,MAAMC,QAAgBlC,EAAIC,QAAQgC,GAClC,GAAIC,EAAQC,GAAI,CAEd,MAAMC,EACJhf,EACqD,QAAnDJ,EAA0C,QAAzCP,EAAAyf,EAAQre,YAAiC,IAAApB,OAAA,EAAAA,EAAAyB,eAAS,IAAAlB,OAAA,EAAAA,EAAAqf,KAAK,KtBhPhC,QsBkPT,QAAZ1d,EAAAud,EAAQre,YAAI,IAAAc,OAAA,EAAAA,EAAEyd,YACfjd,QAAc6a,EAAIgC,YAAYI,EAAYje,GAOhD,OALAgB,EAAMjB,SAAoD,QAAzCJ,EAAAoe,EAAQre,YAAiC,IAAAC,OAAA,EAAAA,EAAAI,UAAW,IACrD,UAAZge,EAAQre,YAAI,IAAAye,OAAA,EAAAA,EAAEve,cAEfoB,EAAoCpB,WAAame,EAAQre,KAAKE,YAE1DoB,CACR,CAED,MAAMkb,MAAmB,QAAbkC,EAAAL,EAAQxB,aAAK,IAAA6B,OAAA,EAAAA,EAAEC,aAK5B,CAJC,MAAOC,GAGP,MADAlE,SAAAA,EAAQmC,MAAM,kCAAmC+B,GAC3CpC,MAAM,2CAA2CoC,IACxD,CACF,EASD9e,gCACEoe,EACAE,EACA9d,GAEA,IAAK4d,IAAiBE,EAAc,MAAM5B,MAAM,6CAEhD,IAEE,aADoBL,EAAI0C,gBAAgBX,EAAc5d,EAKvD,CAHC,MAAOuc,GAEPnC,SAAAA,EAAQoE,IAAI,wCAAwCjC,2BACrD,CAED,OAAOV,EAAI4C,eAAeX,EAAc9d,EACzC,EASDR,wBACE2b,EACA/N,EACApN,SAEA,IAAKmb,EAAW,MAAMe,MAAM,gCAE5B,IAAIzc,EACJ,IACEA,QAAaoc,EAAIV,UAAUuD,SAASvD,EAAW/N,EAIhD,CAHC,MAAOmP,GAEP,MADAnC,SAAAA,EAAQmC,MAAM,gCAAiCA,GACzCL,MAAM,8DAA8DK,IAC3E,CAED,IAAK9c,EAAKue,GAER,MADA5D,SAAAA,EAAQmC,MAAM,gCAAiC9c,EAAK8c,OAC9CL,MAAM,mCAA+C,QAAZ5d,EAAAmB,EAAK8c,aAAO,IAAAje,OAAA,EAAAA,EAAA+f,gBAG7D,MAAMJ,WAAEA,GAAexe,EAAKC,KAC5B,IAAKue,EAEH,MADA7D,SAAAA,EAAQmC,MAAM,gDACRL,MAAM,iCAGd,IAEE,aADoBL,EAAIgC,YAAYI,EAAYje,EAKjD,CAHC,MAAOuc,GAEP,MADAnC,SAAAA,EAAQmC,MAAM,sCAAuCA,GAC/CL,MAAM,kEAAkEK,IAC/E,CACF,EAQDoC,oBAAmB,CAAC/d,EAA8BsP,IACzC2L,EAAI+C,0BAA0Bhe,EAAU,GAAIsP,GASrD2O,sBAAqB,CAACje,EAA8BsP,IAC3C2L,EAAIiD,4BAA4Ble,EAAU,GAAIsP,GAUvD0O,0BACEhe,EACAE,EACAoP,GAGA,GAAIpP,IAAWK,EAA2BP,EAAUE,GAAS,OAAO,EAEpE,MAAMie,EAAUpe,EAA2BC,EtBvWb,csBuW6CE,GAC3E,OAAOoP,EAAY8O,OAAOC,GAASF,EAAQG,SAASD,IACrD,EASDH,4BACEle,EACAE,EACAoP,GAEA,GAAIpP,IAAWK,EAA2BP,EAAUE,GAAS,MAAO,GAEpE,MAAMie,EAAUpe,EAA2BC,EtBzXb,csByX6CE,GAC3E,OAAOoP,EAAYiP,QAAQF,GAASF,EAAQG,SAASD,IACtD,EAQDG,cAAa,CAACxe,EAA8B8H,IACnCmT,EAAIwD,oBAAoBze,EAAU,GAAI8H,GAS/C4W,gBAAe,CAAC1e,EAA8B8H,IACrCmT,EAAI0D,sBAAsB3e,EAAU,GAAI8H,GAUjD2W,oBAAoBze,EAA8BE,EAAgB4H,GAEhE,GAAI5H,IAAWK,EAA2BP,EAAUE,GAAS,OAAO,EAEpE,MAAM0e,EAAa7e,EAA2BC,EtB1ZtB,QsB0ZgDE,GACxE,OAAO4H,EAAMsW,OAAO9N,GAASsO,EAAWN,SAAShO,IAClD,EASDqO,sBAAsB3e,EAA8BE,EAAgB4H,GAClE,GAAI5H,IAAWK,EAA2BP,EAAUE,GAAS,MAAO,GAEpE,MAAM0e,EAAa7e,EAA2BC,EtBxatB,QsBwagDE,GACxE,OAAO4H,EAAMyW,QAAQjO,GAASsO,EAAWN,SAAShO,IACnD,IAGH,OAAOuO,EAAAA,SACL5D,EACA,CACE,mBACA,iBACA,mBACA,sBACA,gBACA,mBACA,uBACA,uBACA,iBACA,gBACA,cACA,yBACA,yBACA,WAEFvc,EACD,EAoBH+Z,GAAQqG,uBtB5d8B,MsB6dtCrG,GAAQsG,uBtB3d8B,KsB4dtCtG,GAAQuG,cG9dO,CACbC,WAAY,UACZC,iBAAkB,UAClBC,eAAgB,UAChBC,iBAAkB,UAClBC,aAAc,UACdC,mBAAoB,UACpBC,qBAAsB,UACtBC,aAAc"}